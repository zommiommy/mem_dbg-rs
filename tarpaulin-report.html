<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","examples","bench_hash_map.rs"],"content":"use cap::Cap;\nuse deepsize::*;\nuse get_size::*;\nuse mem_dbg::*;\nuse std::alloc;\nuse std::collections::HashMap;\nuse std::time::Instant;\n\n#[global_allocator]\nstatic ALLOCATOR: Cap\u003calloc::System\u003e = Cap::new(alloc::System, usize::MAX);\n\nfn main() {\n    const N: usize = 100_000_000;\n    let mut m = HashMap::with_capacity(N);\n    for i in 0..N {\n        m.insert(i, i);\n    }\n\n    println!(\"Allocated:    {}\", ALLOCATOR.allocated());\n\n    let start = Instant::now();\n    let size = m.get_size();\n    println!(\"get_size:     {} {:?} ns\", size, start.elapsed().as_nanos());\n\n    let start = Instant::now();\n    let size = m.deep_size_of();\n    println!(\"deep_size_of: {} {:?} ns\", size, start.elapsed().as_nanos());\n\n    // Commented out as `size-of` crate is currently broken.\n    // let start = Instant::now();\n    // let size = m.size_of().total_bytes();\n    // println!(\"size_of:      {} {:?} ns\", size, start.elapsed().as_nanos());\n\n    let start = Instant::now();\n    let size = m.mem_size(SizeFlags::default());\n    println!(\"mem_size:     {} {:?} ns\", size, start.elapsed().as_nanos());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","examples","example.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n#![cfg_attr(feature = \"offset_of_enum\", feature(offset_of_enum))]\n#![allow(dead_code)]\n\nuse mem_dbg::*;\n\n#[derive(Clone, Copy, MemSize, MemDbg)]\n#[copy_type]\nenum TestEnum {\n    Unit,\n    Unit2(),\n    Unit3 {},\n    Unnamed(usize, u8),\n    Named { first: usize, second: u8 },\n}\n\n#[derive(Clone, Copy, MemSize, MemDbg)]\nstruct TestMarker;\n\n#[derive(Clone, Copy, MemSize, MemDbg)]\nstruct TestTuple(usize, u8);\n\n#[derive(MemSize, MemDbg)]\n#[cfg(feature = \"std\")]\nstruct Struct\u003cA, B\u003e {\n    a: A,\n    b: B,\n    test: isize,\n    h: std::collections::HashSet\u003cusize\u003e,\n}\n\n#[derive(MemSize, MemDbg)]\nstruct Data\u003cA\u003e {\n    a: A,\n    b: Vec\u003ci32\u003e,\n    c: (u8, String),\n}\n\n#[cfg(feature = \"std\")]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut b = Vec::with_capacity(100);\n    b.extend(0..10);\n    let mut h = std::collections::HashSet::with_capacity(100);\n    h.extend(0..10);\n\n    let s = Struct {\n        a: TestEnum::Unnamed(0, 16),\n        b: Data {\n            a: vec![0x42_u8; 700],\n            b: b.clone(),\n            c: (1, \"foo\".to_owned()),\n        },\n        test: -0xbadf00d,\n        h: h.clone(),\n    };\n\n    // print the size in bytes of the value\n    println!(\"size:     {}\", s.mem_size(SizeFlags::default()));\n    println!(\"capacity: {}\", s.mem_size(SizeFlags::CAPACITY));\n\n    println!();\n\n    println!(\"DbgFlags::default():\");\n    println!();\n    s.mem_dbg(DbgFlags::default())?;\n\n    println!();\n\n    println!(\"DbgFlags::default() | DbgFlags::CAPACITY:\");\n    println!();\n    s.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY)?;\n\n    println!();\n\n    println!(\"DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE:\");\n    println!();\n    s.mem_dbg(DbgFlags::default() | DbgFlags::HUMANIZE)?;\n\n    println!();\n\n    println!(\"DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE:\");\n    println!();\n    s.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE)?;\n\n    println!();\n\n    let s = Struct {\n        a: TestEnum::Named {\n            first: 0,\n            second: 1,\n        },\n        b: Data {\n            a: vec![0x42_u8; 700],\n            b,\n            c: (1, \"foo\".to_owned()),\n        },\n        test: -0xbadf00d,\n        h,\n    };\n\n    println!(\"DbgFlags::empty():\");\n    println!();\n    s.mem_dbg(DbgFlags::empty())?;\n\n    #[cfg(feature = \"offset_of_enum\")]\n    {\n        println!();\n        println!(\"DbgFlags::HUMANIZE | DbgFlags::RUST_LAYOUT:\");\n        println!();\n        s.mem_dbg(DbgFlags::HUMANIZE | DbgFlags::RUST_LAYOUT)?;\n    }\n    let s = Struct {\n        a: 0_u8,\n        b: 0_u8,\n        test: 1,\n        h: std::collections::HashSet::new(),\n    };\n\n    println!();\n\n    println!(\"DbgFlags::empty()\");\n    println!();\n    s.mem_dbg(DbgFlags::empty())?;\n\n    println!();\n\n    println!(\"DbgFlags::RUST_LAYOUT\");\n    println!();\n    s.mem_dbg(DbgFlags::RUST_LAYOUT)?;\n\n    Ok(())\n}\n\n#[cfg(not(feature = \"std\"))]\nfn main() {\n    println!(\"This example requires the 'std' feature.\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","examples","readme.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n#![cfg_attr(feature = \"offset_of_enum\", feature(offset_of_enum))]\n#![allow(dead_code)]\n\n#[cfg(feature = \"std\")]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    use mem_dbg::*;\n\n    #[derive(MemSize, MemDbg)]\n    struct Struct\u003cA, B\u003e {\n        a: A,\n        b: B,\n        test: isize,\n    }\n\n    #[derive(MemSize, MemDbg)]\n    struct Data\u003cA\u003e {\n        a: A,\n        b: Vec\u003ci32\u003e,\n        c: (u8, String),\n    }\n\n    #[derive(MemSize, MemDbg)]\n    enum TestEnum {\n        Unit,\n        Unit2(),\n        Unit3 {},\n        Unnamed(usize, usize),\n        Named { first: usize, second: u8 },\n    }\n\n    let b = Vec::with_capacity(100);\n\n    let s = Struct {\n        a: TestEnum::Unnamed(0, 16),\n        b: Data {\n            a: vec![0x42_u8; 700],\n            b,\n            c: (1, \"foo\".to_owned()),\n        },\n        test: -0xbadf00d,\n    };\n\n    println!(\"size:     {}\", s.mem_size(SizeFlags::default()));\n    println!(\"capacity: {}\", s.mem_size(SizeFlags::CAPACITY));\n    println!();\n\n    s.mem_dbg(DbgFlags::empty())?;\n\n    println!();\n\n    println!(\"size:     {}\", s.mem_size(SizeFlags::default()));\n    println!(\"capacity: {}\", s.mem_size(SizeFlags::CAPACITY));\n    println!();\n\n    s.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE)?;\n\n    #[cfg(feature = \"offset_of_enum\")]\n    {\n        println!();\n\n        println!(\"size:     {}\", s.mem_size(SizeFlags::default()));\n        println!(\"capacity: {}\", s.mem_size(SizeFlags::CAPACITY));\n        println!();\n\n        s.mem_dbg(DbgFlags::empty() | DbgFlags::RUST_LAYOUT)?;\n    }\n    Ok(())\n}\n\n#[cfg(not(feature = \"std\"))]\nfn main() {\n    println!(\"This example requires the 'std' feature.\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","src","impl_mem_dbg.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\nuse core::marker::PhantomPinned;\nuse core::num::*;\nuse core::{marker::PhantomData, sync::atomic::*};\n\nuse crate::{CopyType, DbgFlags, MemDbgImpl, impl_mem_size::MemSizeHelper};\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\n\n/// Implements [`MemDbg`] using the default implementation of [`MemDbgImpl`].\nmacro_rules! impl_mem_dbg {\n     ($($ty:ty),*) =\u003e {$(\n impl MemDbgImpl for $ty {}\n     )*};\n }\n\nimpl_mem_dbg! {\n    (), bool, char, f32, f64,\n    u8, u16, u32, u64, u128, usize,\n    i8, i16, i32, i64, i128, isize,\n    AtomicBool,\n    AtomicI8, AtomicI16, AtomicI32, AtomicI64, AtomicIsize,\n    AtomicU8, AtomicU16, AtomicU32, AtomicU64, AtomicUsize,\n    NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize,\n    NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize,\n    PhantomPinned, str, String\n}\n\nimpl\u003cT: ?Sized\u003e MemDbgImpl for PhantomData\u003cT\u003e {}\n\n// References: we recurse only if FOLLOW_REFS is set\nimpl\u003cT: ?Sized + MemDbgImpl\u003e MemDbgImpl for \u0026'_ T {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            (**self)._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\nimpl\u003cT: ?Sized + MemDbgImpl\u003e MemDbgImpl for \u0026'_ mut T {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            (**self)._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n// Option\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for Option\u003cT\u003e {}\n\n// Box\n\nimpl\u003cT: ?Sized + MemDbgImpl\u003e MemDbgImpl for Box\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.as_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::sync::Arc;\n#[cfg(feature = \"std\")]\nuse std::sync::Arc;\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for Arc\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.as_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n// Slices\n\nimpl\u003cT: CopyType + MemDbgImpl\u003e MemDbgImpl for [T] where [T]: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e {}\n\n// Arrays\n\nimpl\u003cT: CopyType + MemDbgImpl, const N: usize\u003e MemDbgImpl for [T; N] where\n    [T; N]: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\n{\n}\n\n// Vectors\n\nimpl\u003cT: CopyType + MemDbgImpl\u003e MemDbgImpl for Vec\u003cT\u003e where\n    Vec\u003cT\u003e: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\n{\n}\n\n// Tuples\n\nmacro_rules! impl_tuples_muncher {\n    () =\u003e {};\n\n    (($idx:tt =\u003e $ty:ident), $(($i:tt =\u003e $t:ident),)*) =\u003e {\n        // Pass to list reversal\n        impl_tuples_muncher!([($idx =\u003e $ty);] $(($i =\u003e $t),)*);\n        // Recurse on tail\n        impl_tuples_muncher!($(($i =\u003e $t),)*);\n    };\n\n    // List reversal\n    ([$(($accIdx: tt =\u003e $accTyp: ident);)+]  ($idx:tt =\u003e $typ:ident), $( ($nidx:tt =\u003e $ntyp:ident), )*) =\u003e {\n        impl_tuples_muncher!([($idx =\u003e $typ); $(($accIdx =\u003e $accTyp); )*] $( ($nidx =\u003e $ntyp), ) *);\n    };\n\n    // Implement on reversed list, building the tuple type as we cannot expand\n    // recursively\n    ([($idx:tt =\u003e $ty:ident); $( ($nidx:tt =\u003e $nty:ident); )*]) =\u003e {\n        impl_tuples_muncher!([($idx =\u003e $ty); $(($nidx =\u003e $nty);)* ], ($ty, $($nty,)*));\n    };\n\n    // Implement on reversed list and tuple type\n    ([($idx:tt =\u003e $ty:ident); $( ($nidx:tt =\u003e $nty:ident); )*], $tty:ty) =\u003e {\n        impl\u003c$ty: crate::MemSize + MemDbgImpl, $($nty: crate::MemSize + MemDbgImpl,)*\u003e MemDbgImpl for ($ty, $($nty,)*)  {\n            fn _mem_dbg_rec_on(\n                \u0026self,\n                writer: \u0026mut impl core::fmt::Write,\n                total_size: usize,\n                max_depth: usize,\n                prefix: \u0026mut String,\n                _is_last: bool,\n                flags: DbgFlags,\n            ) -\u003e core::fmt::Result {\n                // Compute size of tuple minus one for last-field check.\n                let mut _max_idx = $idx;\n                $(_max_idx = _max_idx.max($nidx);)*\n\n                let mut id_sizes: Vec\u003c(usize, usize)\u003e = vec![];\n                let n;\n\n                {\n                    // We use the offset_of information to build the real\n                    // space occupied by a field.\n                    id_sizes.push(($idx, core::mem::offset_of!($tty, $idx)));\n                    $(id_sizes.push(($nidx, core::mem::offset_of!($tty, $nidx)));)*\n                    n = id_sizes.len();\n                    id_sizes.push((n, core::mem::size_of::\u003cSelf\u003e()));\n                    // Sort by offset\n                    id_sizes.sort_by_key(|x| x.1);\n                    // Compute actual sizes\n                    for i in 0..n {\n                        id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;\n                    };\n                    // Put the candle back\n                    id_sizes.sort_by_key(|x| x.0);\n                }\n\n                self.$idx._mem_dbg_depth_on(writer, total_size, max_depth, prefix, Some(stringify!($idx)), $idx == _max_idx, id_sizes[$idx].1, flags)?;\n                $(\n                    self.$nidx._mem_dbg_depth_on(writer, total_size, max_depth, prefix, Some(stringify!($nidx)), $nidx == _max_idx, id_sizes[$nidx].1, flags)?;\n                )*\n                Ok(())\n            }\n        }\n    };\n}\n\nimpl_tuples_muncher!(\n    (9 =\u003e T9),\n    (8 =\u003e T8),\n    (7 =\u003e T7),\n    (6 =\u003e T6),\n    (5 =\u003e T5),\n    (4 =\u003e T4),\n    (3 =\u003e T3),\n    (2 =\u003e T2),\n    (1 =\u003e T1),\n    (0 =\u003e T0),\n);\n\n// Function pointers cannot recurse\n\nimpl\u003cR\u003e MemDbgImpl for fn() -\u003e R {}\nimpl\u003cA, R\u003e MemDbgImpl for fn(A) -\u003e R {}\nimpl\u003cA, B, R\u003e MemDbgImpl for fn(A, B) -\u003e R {}\nimpl\u003cA, B, C, R\u003e MemDbgImpl for fn(A, B, C) -\u003e R {}\nimpl\u003cA, B, C, D, R\u003e MemDbgImpl for fn(A, B, C, D) -\u003e R {}\n\n// Hash-based containers from the standard library\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType\u003e MemDbgImpl for std::collections::HashSet\u003cK\u003e where\n    std::collections::HashSet\u003cK\u003e: MemSizeHelper\u003c\u003cK as CopyType\u003e::Copy\u003e\n{\n}\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType, V: CopyType\u003e MemDbgImpl for std::collections::HashMap\u003cK, V\u003e where\n    std::collections::HashMap\u003cK, V\u003e:\n        crate::impl_mem_size::MemSizeHelper2\u003c\u003cK as CopyType\u003e::Copy, \u003cV as CopyType\u003e::Copy\u003e\n{\n}\n\n// Hash stuff\n\n#[cfg(feature = \"mmap-rs\")]\nimpl_mem_dbg!(mmap_rs::Mmap, mmap_rs::MmapMut);\n\nimpl\u003cH\u003e MemDbgImpl for core::hash::BuildHasherDefault\u003cH\u003e {\n    // it's a phantom data so no recursion\n}\n\n#[cfg(feature = \"std\")]\nimpl MemDbgImpl for std::collections::hash_map::RandomState {\n    // it's two u64s, but they are private so can't recurse\n}\n\n// alloc\n\n#[cfg(feature = \"std\")]\nimpl MemDbgImpl for core::alloc::Layout {\n    // Layout is size + align, but align is unstable so we can't recurse\n    // on that, nor implement memdbg or memsize for that :)\n}\n\n// Ranges\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::Range\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.start\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)?;\n        self.end\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::RangeFrom\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.start\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::RangeInclusive\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.start()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)?;\n        self.end()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::RangeTo\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.end\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::RangeToInclusive\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.end\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e MemDbgImpl for core::ptr::NonNull\u003cT\u003e {\n    // no recursion because we don't follow pointers\n}\n\n// Rand crate\n\n#[cfg(feature = \"rand\")]\nimpl_mem_dbg!(\n    rand::rngs::SmallRng,\n    rand::rngs::StdRng,\n    rand::rngs::ThreadRng\n);\n\n// Cells\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for core::cell::RefCell\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.borrow()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for core::cell::Cell\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        unsafe {\n            (*self.as_ptr())._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        }\n    }\n}\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for core::cell::UnsafeCell\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        unsafe {\n            (*self.get())._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        }\n    }\n}\n\n// Mutexes\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::Mutex\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.lock()\n            .unwrap()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::RwLock\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.read()\n            .unwrap()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::cell::OnceCell\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.get()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::MutexGuard\u003c'_, T\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        use core::ops::Deref;\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            self.deref()\n                ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::RwLockReadGuard\u003c'_, T\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        use core::ops::Deref;\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            self.deref()\n                ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::RwLockWriteGuard\u003c'_, T\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        use core::ops::Deref;\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            self.deref()\n                ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n// Os stuff\n\n#[cfg(feature = \"std\")]\nimpl_mem_dbg!(\n    std::path::Path,\n    std::path::PathBuf,\n    std::ffi::OsStr,\n    std::ffi::OsString,\n    std::fs::File,\n    std::fs::OpenOptions,\n    std::fs::Metadata,\n    std::fs::FileTimes,\n    std::fs::FileType,\n    std::fs::Permissions\n);\n\n// I/O\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl + std::io::Read\u003e MemDbgImpl for std::io::BufReader\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.get_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl + std::io::Write\u003e MemDbgImpl for std::io::BufWriter\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.get_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::io::Cursor\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.get_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n// maligned crate\n\n#[cfg(feature = \"maligned\")]\nimpl_mem_dbg!(\n    maligned::A2,\n    maligned::A4,\n    maligned::A8,\n    maligned::A16,\n    maligned::A32,\n    maligned::A64,\n    maligned::A128,\n    maligned::A256,\n    maligned::A512\n);\n\n#[cfg(feature = \"maligned\")]\nimpl\u003cA: maligned::Alignment, T: MemDbgImpl\u003e MemDbgImpl for maligned::Aligned\u003cA, T\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        use core::ops::Deref;\n        self.deref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n// half crate\n\n#[cfg(feature = \"half\")]\nimpl_mem_dbg!(half::f16, half::bf16);\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":28}},{"line":103,"address":[],"length":0,"stats":{"Line":5}},{"line":112,"address":[],"length":0,"stats":{"Line":5}},{"line":113,"address":[],"length":0,"stats":{"Line":35}},{"line":161,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":12}},{"line":163,"address":[],"length":0,"stats":{"Line":12}},{"line":164,"address":[],"length":0,"stats":{"Line":12}},{"line":165,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":12}},{"line":168,"address":[],"length":0,"stats":{"Line":12}},{"line":169,"address":[],"length":0,"stats":{"Line":12}},{"line":171,"address":[],"length":0,"stats":{"Line":12}},{"line":172,"address":[],"length":0,"stats":{"Line":12}},{"line":174,"address":[],"length":0,"stats":{"Line":36}},{"line":180,"address":[],"length":0,"stats":{"Line":36}},{"line":181,"address":[],"length":0,"stats":{"Line":36}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":36}},{"line":185,"address":[],"length":0,"stats":{"Line":24}},{"line":187,"address":[],"length":0,"stats":{"Line":84}},{"line":188,"address":[],"length":0,"stats":{"Line":108}},{"line":191,"address":[],"length":0,"stats":{"Line":24}},{"line":194,"address":[],"length":0,"stats":{"Line":120}},{"line":196,"address":[],"length":0,"stats":{"Line":120}},{"line":198,"address":[],"length":0,"stats":{"Line":12}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":28}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":28}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":290,"address":[],"length":0,"stats":{"Line":4}},{"line":291,"address":[],"length":0,"stats":{"Line":28}},{"line":296,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":28}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":28}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":323,"address":[],"length":0,"stats":{"Line":28}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":4}},{"line":338,"address":[],"length":0,"stats":{"Line":28}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":8}},{"line":368,"address":[],"length":0,"stats":{"Line":24}},{"line":373,"address":[],"length":0,"stats":{"Line":4}},{"line":383,"address":[],"length":0,"stats":{"Line":32}},{"line":389,"address":[],"length":0,"stats":{"Line":4}},{"line":399,"address":[],"length":0,"stats":{"Line":32}},{"line":408,"address":[],"length":0,"stats":{"Line":5}},{"line":417,"address":[],"length":0,"stats":{"Line":10}},{"line":419,"address":[],"length":0,"stats":{"Line":35}},{"line":425,"address":[],"length":0,"stats":{"Line":4}},{"line":434,"address":[],"length":0,"stats":{"Line":8}},{"line":436,"address":[],"length":0,"stats":{"Line":28}},{"line":442,"address":[],"length":0,"stats":{"Line":4}},{"line":451,"address":[],"length":0,"stats":{"Line":4}},{"line":452,"address":[],"length":0,"stats":{"Line":28}},{"line":458,"address":[],"length":0,"stats":{"Line":5}},{"line":468,"address":[],"length":0,"stats":{"Line":10}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":5}},{"line":479,"address":[],"length":0,"stats":{"Line":4}},{"line":489,"address":[],"length":0,"stats":{"Line":8}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":4}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":4}},{"line":548,"address":[],"length":0,"stats":{"Line":4}},{"line":549,"address":[],"length":0,"stats":{"Line":28}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":564,"address":[],"length":0,"stats":{"Line":4}},{"line":565,"address":[],"length":0,"stats":{"Line":28}},{"line":571,"address":[],"length":0,"stats":{"Line":4}},{"line":580,"address":[],"length":0,"stats":{"Line":4}},{"line":581,"address":[],"length":0,"stats":{"Line":28}},{"line":602,"address":[],"length":0,"stats":{"Line":2}},{"line":612,"address":[],"length":0,"stats":{"Line":2}},{"line":613,"address":[],"length":0,"stats":{"Line":14}}],"covered":88,"coverable":99},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","src","impl_mem_size.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\nuse core::marker::{PhantomData, PhantomPinned};\nuse core::num::*;\nuse core::sync::atomic::*;\n\nuse crate::{Boolean, CopyType, False, MemSize, SizeFlags, True};\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::string::String;\n\n#[cfg(feature = \"std\")]\n/// A basic implementation using [`core::mem::size_of`] for non-[`Copy`] types,\n/// setting [`CopyType::Copy`] to [`False`].\nmacro_rules! impl_size_of {\n    ($($ty:ty),*) =\u003e {$(\n        impl CopyType for $ty {\n            type Copy = False;\n        }\n\n        impl MemSize for $ty {\n            #[inline(always)]\n            fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n                core::mem::size_of::\u003cSelf\u003e()\n            }\n        }\n    )*};\n}\n\n/// A basic implementation using [`core::mem::size_of`] for [`Copy`] types,\n/// setting [`CopyType::Copy`] to [`True`].\nmacro_rules! impl_copy_size_of {\n    ($($ty:ty),*) =\u003e {$(\n        impl CopyType for $ty {\n            type Copy = True;\n        }\n\n        impl MemSize for $ty {\n            #[inline(always)]\n            fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n                core::mem::size_of::\u003cSelf\u003e()\n            }\n        }\n    )*};\n}\n\nimpl_copy_size_of! {\n   (), bool, char, f32, f64,\n   u8, u16, u32, u64, u128, usize,\n   i8, i16, i32, i64, i128, isize,\n   AtomicBool,\n   AtomicI8, AtomicI16, AtomicI32, AtomicI64, AtomicIsize,\n   AtomicU8, AtomicU16, AtomicU32, AtomicU64, AtomicUsize,\n   NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize,\n   NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize,\n   PhantomPinned\n}\n\n// Strings\n\nimpl CopyType for str {\n    type Copy = False;\n}\n\nimpl MemSize for str {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cusize\u003e() + self.len()\n    }\n}\n\nimpl CopyType for String {\n    type Copy = False;\n}\n\nimpl MemSize for String {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::CAPACITY) {\n            core::mem::size_of::\u003cSelf\u003e() + self.capacity()\n        } else {\n            core::mem::size_of::\u003cSelf\u003e() + self.len()\n        }\n    }\n}\n\n// PhantomData\n\nimpl\u003cT\u003e CopyType for PhantomData\u003cT\u003e {\n    type Copy = True;\n}\n\nimpl\u003cT: ?Sized\u003e MemSize for PhantomData\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        0\n    }\n}\n\n// References: we recurse only if FOLLOW_REFS is set\n\nimpl\u003cT: ?Sized + MemSize\u003e CopyType for \u0026'_ T {\n    type Copy = False;\n}\n\nimpl\u003cT: ?Sized + MemSize\u003e MemSize for \u0026'_ T {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            core::mem::size_of::\u003cSelf\u003e() + \u003cT as MemSize\u003e::mem_size(*self, flags)\n        } else {\n            core::mem::size_of::\u003cSelf\u003e()\n        }\n    }\n}\n\nimpl\u003cT: ?Sized + MemSize\u003e CopyType for \u0026'_ mut T {\n    type Copy = False;\n}\n\nimpl\u003cT: ?Sized + MemSize\u003e MemSize for \u0026'_ mut T {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003c\u0026'_ T as MemSize\u003e::mem_size(\u0026\u0026**self, flags)\n    }\n}\n\n// Option\n\nimpl\u003cT: CopyType + MemSize\u003e CopyType for Option\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for Option\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + self.as_ref().map_or(0, |x| {\n                \u003cT as MemSize\u003e::mem_size(x, flags) - core::mem::size_of::\u003cT\u003e()\n            })\n    }\n}\n\n// Box\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::boxed::Box;\nimpl\u003cT: ?Sized + MemSize\u003e MemSize for Box\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cT as MemSize\u003e::mem_size(self.as_ref(), flags)\n    }\n}\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::sync::Arc;\n#[cfg(feature = \"std\")]\nuse std::sync::Arc;\nimpl\u003cT: MemSize\u003e MemSize for Arc\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cT as MemSize\u003e::mem_size(self.as_ref(), flags)\n            - core::mem::size_of::\u003cT\u003e()\n    }\n}\n\n/// A helper trait that makes it possible to implement differently\n/// the size computation for arrays, vectors, and slices of\n/// [`Copy`] types.\n///\n/// See [`crate::CopyType`] for more information.\npub trait MemSizeHelper\u003cT: Boolean\u003e {\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize;\n}\n\n// Slices\n\nimpl\u003cT: CopyType\u003e MemSize for [T]\nwhere\n    [T]: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003c[T] as MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\u003e::mem_size_impl(self, flags)\n    }\n}\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::vec::Vec;\nimpl\u003cT: CopyType + MemSize\u003e MemSizeHelper\u003cTrue\u003e for [T] {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of_val(self)\n    }\n}\n\nimpl\u003cT: CopyType + MemSize\u003e MemSizeHelper\u003cFalse\u003e for [T] {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        self.iter()\n            .map(|x| \u003cT as MemSize\u003e::mem_size(x, flags))\n            .sum::\u003cusize\u003e()\n    }\n}\n\n// Arrays\n\nimpl\u003cT: CopyType + MemSize, const N: usize\u003e CopyType for [T; N] {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: CopyType, const N: usize\u003e MemSize for [T; N]\nwhere\n    [T; N]: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003c[T; N] as MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\u003e::mem_size_impl(self, flags)\n    }\n}\n\nimpl\u003cT: MemSize, const N: usize\u003e MemSizeHelper\u003cTrue\u003e for [T; N] {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cT: MemSize, const N: usize\u003e MemSizeHelper\u003cFalse\u003e for [T; N] {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + self\n                .iter()\n                .map(|x| \u003cT as MemSize\u003e::mem_size(x, flags) - core::mem::size_of::\u003cT\u003e())\n                .sum::\u003cusize\u003e()\n    }\n}\n\n// Vectors\n\nimpl\u003cT\u003e CopyType for Vec\u003cT\u003e {\n    type Copy = False;\n}\n\nimpl\u003cT: CopyType\u003e MemSize for Vec\u003cT\u003e\nwhere\n    Vec\u003cT\u003e: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003cVec\u003cT\u003e as MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\u003e::mem_size_impl(self, flags)\n    }\n}\n\nimpl\u003cT: CopyType + MemSize\u003e MemSizeHelper\u003cTrue\u003e for Vec\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::CAPACITY) {\n            core::mem::size_of::\u003cSelf\u003e() + self.capacity() * core::mem::size_of::\u003cT\u003e()\n        } else {\n            core::mem::size_of::\u003cSelf\u003e() + self.len() * core::mem::size_of::\u003cT\u003e()\n        }\n    }\n}\n\nimpl\u003cT: CopyType + MemSize\u003e MemSizeHelper\u003cFalse\u003e for Vec\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::CAPACITY) {\n            core::mem::size_of::\u003cSelf\u003e()\n                + self\n                    .iter()\n                    .map(|x| \u003cT as MemSize\u003e::mem_size(x, flags))\n                    .sum::\u003cusize\u003e()\n                + (self.capacity() - self.len()) * core::mem::size_of::\u003cT\u003e()\n        } else {\n            core::mem::size_of::\u003cSelf\u003e()\n                + self\n                    .iter()\n                    .map(|x| \u003cT as MemSize\u003e::mem_size(x, flags))\n                    .sum::\u003cusize\u003e()\n        }\n    }\n}\n\n// Tuples\n\nmacro_rules! impl_tuples_muncher {\n    () =\u003e {};\n\n    (($idx:tt =\u003e $ty:ident), $(($i:tt =\u003e $t:ident),)*) =\u003e {\n        // Pass to list reversal\n        impl_tuples_muncher!([($idx =\u003e $ty);] $(($i =\u003e $t),)*);\n        // Recurse on tail\n        impl_tuples_muncher!($(($i =\u003e $t),)*);\n    };\n\n    // List reversal\n    ([$(($accIdx: tt =\u003e $accTyp: ident);)+]  ($idx:tt =\u003e $typ:ident), $( ($nidx:tt =\u003e $ntyp:ident), )*) =\u003e {\n        impl_tuples_muncher!([($idx =\u003e $typ); $(($accIdx =\u003e $accTyp); )*] $( ($nidx =\u003e $ntyp), ) *);\n    };\n\n    // Implement on reversed list\n    ([($idx:tt =\u003e $ty:ident); $( ($nidx:tt =\u003e $nty:ident); )*]) =\u003e {\n        impl\u003c$ty, $($nty,)*\u003e CopyType for ($ty, $($nty,)*)  {\n            type Copy = False;\n\t\t}\n\n\t\timpl\u003c$ty: MemSize, $($nty: MemSize,)*\u003e MemSize for ($ty, $($nty,)*)\n        {\n            #[inline(always)]\n            fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n                let mut bytes = core::mem::size_of::\u003cSelf\u003e();\n                bytes += \u003c$ty as MemSize\u003e::mem_size(\u0026self.$idx, flags) - core::mem::size_of::\u003c$ty\u003e();\n                $( bytes += \u003c$nty as MemSize\u003e::mem_size(\u0026self.$nidx, flags) - core::mem::size_of::\u003c$nty\u003e(); )*\n                bytes\n            }\n        }\n    }\n\n}\n\nimpl_tuples_muncher!(\n    (9 =\u003e T9),\n    (8 =\u003e T8),\n    (7 =\u003e T7),\n    (6 =\u003e T6),\n    (5 =\u003e T5),\n    (4 =\u003e T4),\n    (3 =\u003e T3),\n    (2 =\u003e T2),\n    (1 =\u003e T1),\n    (0 =\u003e T0),\n);\n\n// Functions\n\nimpl\u003cR\u003e CopyType for fn() -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cR\u003e MemSize for fn() -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cA, R\u003e CopyType for fn(A) -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cA, R\u003e MemSize for fn(A) -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cA, B, R\u003e CopyType for fn(A, B) -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cA, B, R\u003e MemSize for fn(A, B) -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cA, B, C, R\u003e CopyType for fn(A, B, C) -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cA, B, C, R\u003e MemSize for fn(A, B, C) -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cA, B, C, D, R\u003e CopyType for fn(A, B, C, D) -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cA, B, C, D, R\u003e MemSize for fn(A, B, C, D) -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\n// Ranges\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::Range\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::Range\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + \u003cIdx as MemSize\u003e::mem_size(\u0026self.start, flags)\n            + \u003cIdx as MemSize\u003e::mem_size(\u0026self.end, flags)\n            - 2 * core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::RangeFrom\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::RangeFrom\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cIdx as MemSize\u003e::mem_size(\u0026self.start, flags)\n            - core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::RangeInclusive\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::RangeInclusive\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + \u003cIdx as MemSize\u003e::mem_size(self.start(), flags)\n            + \u003cIdx as MemSize\u003e::mem_size(self.end(), flags)\n            - 2 * core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::RangeTo\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::RangeTo\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cIdx as MemSize\u003e::mem_size(\u0026self.end, flags)\n            - core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::RangeToInclusive\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::RangeToInclusive\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cIdx as MemSize\u003e::mem_size(\u0026self.end, flags)\n            - core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\n// Rand crate\n\n#[cfg(feature = \"rand\")]\nimpl_copy_size_of!(\n    rand::rngs::SmallRng,\n    rand::rngs::ThreadRng,\n    rand::rngs::StdRng\n);\n\n// Cells\n\nimpl\u003cT: CopyType\u003e CopyType for core::cell::RefCell\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for core::cell::RefCell\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(\u0026self.borrow(), flags)\n    }\n}\n\nimpl\u003cT: CopyType\u003e CopyType for core::cell::Cell\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for core::cell::Cell\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + unsafe { \u003cT as MemSize\u003e::mem_size(\u0026*self.as_ptr(), flags) }\n    }\n}\n\nimpl\u003cT: CopyType\u003e CopyType for core::cell::OnceCell\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for core::cell::OnceCell\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cOption\u003c\u0026T\u003e as MemSize\u003e::mem_size(\u0026self.get(), flags)\n    }\n}\n\nimpl\u003cT: CopyType\u003e CopyType for core::cell::UnsafeCell\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for core::cell::UnsafeCell\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + unsafe { \u003cT as MemSize\u003e::mem_size(\u0026*self.get(), flags) }\n            - core::mem::size_of::\u003cT\u003e()\n    }\n}\n\n// Mutexes\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::Mutex\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::Mutex\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(\u0026self.lock().unwrap(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::RwLock\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::RwLock\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(\u0026self.read().unwrap(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::MutexGuard\u003c'_, T\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::MutexGuard\u003c'_, T\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        use core::ops::Deref;\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n                + \u003cT as MemSize\u003e::mem_size(self.deref(), flags)\n        } else {\n            0\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::RwLockReadGuard\u003c'_, T\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::RwLockReadGuard\u003c'_, T\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        use core::ops::Deref;\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n                + \u003cT as MemSize\u003e::mem_size(self.deref(), flags)\n        } else {\n            0\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::RwLockWriteGuard\u003c'_, T\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::RwLockWriteGuard\u003c'_, T\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        use core::ops::Deref;\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n                + \u003cT as MemSize\u003e::mem_size(self.deref(), flags)\n        } else {\n            0\n        }\n    }\n}\n\n// OS stuff\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::path::Path {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::path::Path {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003cstd::ffi::OsStr as MemSize\u003e::mem_size(self.as_os_str(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::path::PathBuf {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::path::PathBuf {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + if flags.contains(SizeFlags::CAPACITY) {\n                self.capacity()\n            } else {\n                \u003cstd::ffi::OsStr as MemSize\u003e::mem_size(self.as_os_str(), flags)\n            }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::ffi::OsStr {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::ffi::OsStr {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            // OsStr is unsized, so we can only return the length of the data\n            self.as_encoded_bytes().len()\n        } else {\n            0\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::ffi::OsString {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::ffi::OsString {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        // OsString is like String - it has heap-allocated data\n        // We use len() by default, and capacity() with CAPACITY flag\n        core::mem::size_of::\u003cSelf\u003e()\n            + if flags.contains(SizeFlags::CAPACITY) {\n                self.capacity()\n            } else {\n                self.len()\n            }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl_size_of!(\n    std::fs::File,\n    std::fs::OpenOptions,\n    std::fs::Metadata,\n    std::fs::FileType,\n    std::fs::FileTimes,\n    std::fs::Permissions\n);\n\n// I/O\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize + std::io::Read\u003e CopyType for std::io::BufReader\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize + std::io::Read\u003e MemSize for std::io::BufReader\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(self.get_ref(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize + std::io::Write\u003e CopyType for std::io::BufWriter\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize + std::io::Write\u003e MemSize for std::io::BufWriter\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(self.get_ref(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT\u003e CopyType for std::io::Cursor\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::io::Cursor\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(self.get_ref(), flags)\n    }\n}\n\n// IpAddr\n#[cfg(feature = \"std\")]\nimpl_copy_size_of!(\n    std::net::Ipv4Addr,\n    std::net::Ipv6Addr,\n    std::net::IpAddr,\n    std::net::SocketAddrV4,\n    std::net::SocketAddrV6,\n    std::net::SocketAddr\n);\n\n// Time\n#[cfg(feature = \"std\")]\nimpl_copy_size_of!(\n    std::time::Duration,\n    std::time::Instant,\n    std::time::SystemTime,\n    std::time::SystemTimeError\n);\n\n// mmap-rs crate\n\n#[cfg(feature = \"mmap-rs\")]\nimpl CopyType for mmap_rs::Mmap {\n    type Copy = False;\n}\n\n#[cfg(feature = \"mmap-rs\")]\nimpl MemSize for mmap_rs::Mmap {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + if flags.contains(SizeFlags::FOLLOW_REFS) {\n                self.len()\n            } else {\n                0\n            }\n    }\n}\n\n#[cfg(feature = \"mmap-rs\")]\nimpl CopyType for mmap_rs::MmapMut {\n    type Copy = False;\n}\n\n#[cfg(feature = \"mmap-rs\")]\nimpl MemSize for mmap_rs::MmapMut {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + if flags.contains(SizeFlags::FOLLOW_REFS) {\n                self.len()\n            } else {\n                0\n            }\n    }\n}\n\n#[cfg(feature = \"std\")]\n// Hash-based containers from the standard library\n//\n// If the standard library changes load factor, this code will have to change\n// accordingly.\n\n// Straight from hashbrown\nfn capacity_to_buckets(cap: usize) -\u003e Option\u003cusize\u003e {\n    // TODO: check that cap == 0 is handled correctly (we presently return 4)\n\n    // For small tables we require at least 1 empty bucket so that lookups are\n    // guaranteed to terminate if an element doesn't exist in the table.\n    if cap \u003c 8 {\n        // We don't bother with a table size of 2 buckets since that can only\n        // hold a single element. Instead we skip directly to a 4 bucket table\n        // which can hold 3 elements.\n        return Some(if cap \u003c 4 { 4 } else { 8 });\n    }\n\n    // Otherwise require 1/8 buckets to be empty (87.5% load)\n    //\n    // Be careful when modifying this, calculate_layout relies on the\n    // overflow check here.\n    let adjusted_cap = cap.checked_mul(8)? / 7;\n\n    // Any overflows will have been caught by the checked_mul. Also, any\n    // rounding errors from the division above will be cleaned up by\n    // next_power_of_two (which can't overflow because of the previous division).\n    Some(adjusted_cap.next_power_of_two())\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e MemSize for std::collections::HashSet\u003cT\u003e\nwhere\n    std::collections::HashSet\u003cT\u003e: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003cstd::collections::HashSet\u003cT\u003e as MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\u003e::mem_size_impl(\n            self, flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\n// Add to the given size the space occupied on the stack by the hash set, by the unused\n// but unavoidable buckets, by the speedup bytes of Swiss Tables, and if `flags` contains\n// `SizeFlags::CAPACITY`, by empty buckets.\nfn fix_set_for_capacity\u003cK\u003e(\n    hash_set: \u0026std::collections::HashSet\u003cK\u003e,\n    size: usize,\n    flags: SizeFlags,\n) -\u003e usize {\n    core::mem::size_of::\u003cstd::collections::HashSet\u003cK\u003e\u003e()\n        + size\n        + if flags.contains(SizeFlags::CAPACITY) {\n            (capacity_to_buckets(hash_set.capacity()).unwrap_or(usize::MAX) - hash_set.len())\n                * core::mem::size_of::\u003cK\u003e()\n                + capacity_to_buckets(hash_set.capacity()).unwrap_or(usize::MAX)\n                    * core::mem::size_of::\u003cu8\u003e()\n        } else {\n            (capacity_to_buckets(hash_set.len()).unwrap_or(usize::MAX) - hash_set.len())\n                * core::mem::size_of::\u003cK\u003e()\n                + capacity_to_buckets(hash_set.len()).unwrap_or(usize::MAX)\n                    * core::mem::size_of::\u003cu8\u003e()\n        }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize\u003e MemSizeHelper\u003cTrue\u003e for std::collections::HashSet\u003cK\u003e {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_set_for_capacity(self, core::mem::size_of::\u003cK\u003e() * self.len(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize\u003e MemSizeHelper\u003cFalse\u003e for std::collections::HashSet\u003cK\u003e {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_set_for_capacity(\n            self,\n            self.iter()\n                .map(|x| \u003cK as MemSize\u003e::mem_size(x, flags))\n                .sum::\u003cusize\u003e(),\n            flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\n/// A helper trait that makes it possible to implement differently\n/// the size computation for maps in which keys or values are\n/// [`Copy`] types.\n///\n/// See [`crate::CopyType`] for more information.\npub trait MemSizeHelper2\u003cK: Boolean, V: Boolean\u003e {\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType, V: CopyType\u003e MemSize for std::collections::HashMap\u003cK, V\u003e\nwhere\n    std::collections::HashMap\u003cK, V\u003e: MemSizeHelper2\u003c\u003cK as CopyType\u003e::Copy, \u003cV as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003cstd::collections::HashMap\u003cK, V\u003e as MemSizeHelper2\u003c\n            \u003cK as CopyType\u003e::Copy,\n            \u003cV as CopyType\u003e::Copy,\n        \u003e\u003e::mem_size_impl(self, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\n// Add to the given size the space occupied on the stack by the hash map, by the unused\n// but unavoidable buckets, by the speedup bytes of Swiss Tables, and if `flags` contains\n// `SizeFlags::CAPACITY`, by empty buckets.\nfn fix_map_for_capacity\u003cK, V\u003e(\n    hash_map: \u0026std::collections::HashMap\u003cK, V\u003e,\n    size: usize,\n    flags: SizeFlags,\n) -\u003e usize {\n    core::mem::size_of::\u003cstd::collections::HashSet\u003cK\u003e\u003e()\n        + size\n        + if flags.contains(SizeFlags::CAPACITY) {\n            (capacity_to_buckets(hash_map.capacity()).unwrap_or(usize::MAX) - hash_map.len())\n                * (core::mem::size_of::\u003cK\u003e() + core::mem::size_of::\u003cV\u003e())\n                + capacity_to_buckets(hash_map.capacity()).unwrap_or(usize::MAX)\n                    * core::mem::size_of::\u003cu8\u003e()\n        } else {\n            (capacity_to_buckets(hash_map.len()).unwrap_or(usize::MAX) - hash_map.len())\n                * (core::mem::size_of::\u003cK\u003e() + core::mem::size_of::\u003cV\u003e())\n                + capacity_to_buckets(hash_map.len()).unwrap_or(usize::MAX)\n                    * core::mem::size_of::\u003cu8\u003e()\n        }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize, V: CopyType + MemSize\u003e MemSizeHelper2\u003cTrue, True\u003e\n    for std::collections::HashMap\u003cK, V\u003e\n{\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_map_for_capacity(\n            self,\n            (core::mem::size_of::\u003cK\u003e() + core::mem::size_of::\u003cV\u003e()) * self.len(),\n            flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize, V: CopyType + MemSize\u003e MemSizeHelper2\u003cTrue, False\u003e\n    for std::collections::HashMap\u003cK, V\u003e\n{\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_map_for_capacity(\n            self,\n            (core::mem::size_of::\u003cK\u003e()) * self.len()\n                + self\n                    .values()\n                    .map(|v| \u003cV as MemSize\u003e::mem_size(v, flags))\n                    .sum::\u003cusize\u003e(),\n            flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize, V: CopyType + MemSize\u003e MemSizeHelper2\u003cFalse, True\u003e\n    for std::collections::HashMap\u003cK, V\u003e\n{\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_map_for_capacity(\n            self,\n            self.keys()\n                .map(|k| \u003cK as MemSize\u003e::mem_size(k, flags))\n                .sum::\u003cusize\u003e()\n                + (core::mem::size_of::\u003cV\u003e()) * self.len(),\n            flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize, V: CopyType + MemSize\u003e MemSizeHelper2\u003cFalse, False\u003e\n    for std::collections::HashMap\u003cK, V\u003e\n{\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_map_for_capacity(\n            self,\n            self.iter()\n                .map(|(k, v)| {\n                    \u003cK as MemSize\u003e::mem_size(k, flags) + \u003cV as MemSize\u003e::mem_size(v, flags)\n                })\n                .sum::\u003cusize\u003e(),\n            flags,\n        )\n    }\n}\n\n// Hash\n\nimpl\u003cH\u003e CopyType for core::hash::BuildHasherDefault\u003cH\u003e {\n    type Copy = True;\n}\nimpl\u003cH\u003e MemSize for core::hash::BuildHasherDefault\u003cH\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        // it's a phantom hash\n        debug_assert_eq!(core::mem::size_of::\u003cSelf\u003e(), 0);\n        0\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::hash::DefaultHasher {\n    type Copy = True;\n}\n\n#[cfg(feature = \"std\")]\n// This implementation assumes that DefaultHasher is a fixed-size type\n// that does not allocate memory on the heap.\nimpl MemSize for std::hash::DefaultHasher {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::collections::hash_map::RandomState {\n    type Copy = True;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::collections::hash_map::RandomState {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\n// Memory stuff\n\nimpl_copy_size_of!(core::alloc::Layout);\n\nimpl\u003cT: ?Sized\u003e CopyType for core::ptr::NonNull\u003cT\u003e {\n    type Copy = True;\n}\n\nimpl\u003cT: ?Sized\u003e MemSize for core::ptr::NonNull\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\n// maligned crate\n\n#[cfg(feature = \"maligned\")]\nimpl_copy_size_of!(\n    maligned::A2,\n    maligned::A4,\n    maligned::A8,\n    maligned::A16,\n    maligned::A32,\n    maligned::A64,\n    maligned::A128,\n    maligned::A256,\n    maligned::A512\n);\n\n#[cfg(feature = \"maligned\")]\nimpl\u003cA: maligned::Alignment, T: MemSize\u003e CopyType for maligned::Aligned\u003cA, T\u003e {\n    type Copy = True;\n}\n\n#[cfg(feature = \"maligned\")]\nimpl\u003cA: maligned::Alignment, T: MemSize\u003e MemSize for maligned::Aligned\u003cA, T\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        use core::ops::Deref;\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(self.deref(), flags)\n    }\n}\n\n// half crate\n\n#[cfg(feature = \"half\")]\nimpl_copy_size_of!(half::f16, half::bf16);\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":30,"address":[],"length":0,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":916}},{"line":47,"address":[],"length":0,"stats":{"Line":916}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":18}},{"line":85,"address":[],"length":0,"stats":{"Line":36}},{"line":86,"address":[],"length":0,"stats":{"Line":14}},{"line":88,"address":[],"length":0,"stats":{"Line":22}},{"line":101,"address":[],"length":0,"stats":{"Line":15}},{"line":102,"address":[],"length":0,"stats":{"Line":15}},{"line":114,"address":[],"length":0,"stats":{"Line":140}},{"line":115,"address":[],"length":0,"stats":{"Line":280}},{"line":116,"address":[],"length":0,"stats":{"Line":150}},{"line":118,"address":[],"length":0,"stats":{"Line":90}},{"line":129,"address":[],"length":0,"stats":{"Line":62}},{"line":130,"address":[],"length":0,"stats":{"Line":186}},{"line":142,"address":[],"length":0,"stats":{"Line":57}},{"line":143,"address":[],"length":0,"stats":{"Line":57}},{"line":144,"address":[],"length":0,"stats":{"Line":221}},{"line":145,"address":[],"length":0,"stats":{"Line":150}},{"line":156,"address":[],"length":0,"stats":{"Line":20}},{"line":157,"address":[],"length":0,"stats":{"Line":60}},{"line":167,"address":[],"length":0,"stats":{"Line":18}},{"line":168,"address":[],"length":0,"stats":{"Line":54}},{"line":169,"address":[],"length":0,"stats":{"Line":18}},{"line":189,"address":[],"length":0,"stats":{"Line":26}},{"line":190,"address":[],"length":0,"stats":{"Line":78}},{"line":198,"address":[],"length":0,"stats":{"Line":20}},{"line":199,"address":[],"length":0,"stats":{"Line":40}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[],"length":0,"stats":{"Line":12}},{"line":207,"address":[],"length":0,"stats":{"Line":186}},{"line":223,"address":[],"length":0,"stats":{"Line":20}},{"line":224,"address":[],"length":0,"stats":{"Line":60}},{"line":230,"address":[],"length":0,"stats":{"Line":17}},{"line":231,"address":[],"length":0,"stats":{"Line":17}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":123}},{"line":242,"address":[],"length":0,"stats":{"Line":3}},{"line":257,"address":[],"length":0,"stats":{"Line":49}},{"line":258,"address":[],"length":0,"stats":{"Line":147}},{"line":264,"address":[],"length":0,"stats":{"Line":32}},{"line":265,"address":[],"length":0,"stats":{"Line":64}},{"line":266,"address":[],"length":0,"stats":{"Line":36}},{"line":268,"address":[],"length":0,"stats":{"Line":60}},{"line":275,"address":[],"length":0,"stats":{"Line":17}},{"line":276,"address":[],"length":0,"stats":{"Line":34}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":16}},{"line":285,"address":[],"length":0,"stats":{"Line":16}},{"line":286,"address":[],"length":0,"stats":{"Line":16}},{"line":287,"address":[],"length":0,"stats":{"Line":121}},{"line":288,"address":[],"length":0,"stats":{"Line":16}},{"line":319,"address":[],"length":0,"stats":{"Line":46}},{"line":320,"address":[],"length":0,"stats":{"Line":92}},{"line":321,"address":[],"length":0,"stats":{"Line":138}},{"line":322,"address":[],"length":0,"stats":{"Line":138}},{"line":323,"address":[],"length":0,"stats":{"Line":46}},{"line":351,"address":[],"length":0,"stats":{"Line":14}},{"line":352,"address":[],"length":0,"stats":{"Line":14}},{"line":362,"address":[],"length":0,"stats":{"Line":14}},{"line":363,"address":[],"length":0,"stats":{"Line":14}},{"line":373,"address":[],"length":0,"stats":{"Line":14}},{"line":374,"address":[],"length":0,"stats":{"Line":14}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":14}},{"line":409,"address":[],"length":0,"stats":{"Line":42}},{"line":410,"address":[],"length":0,"stats":{"Line":42}},{"line":411,"address":[],"length":0,"stats":{"Line":28}},{"line":412,"address":[],"length":0,"stats":{"Line":14}},{"line":422,"address":[],"length":0,"stats":{"Line":14}},{"line":423,"address":[],"length":0,"stats":{"Line":42}},{"line":424,"address":[],"length":0,"stats":{"Line":14}},{"line":434,"address":[],"length":0,"stats":{"Line":14}},{"line":435,"address":[],"length":0,"stats":{"Line":42}},{"line":436,"address":[],"length":0,"stats":{"Line":42}},{"line":437,"address":[],"length":0,"stats":{"Line":28}},{"line":438,"address":[],"length":0,"stats":{"Line":14}},{"line":448,"address":[],"length":0,"stats":{"Line":14}},{"line":449,"address":[],"length":0,"stats":{"Line":42}},{"line":450,"address":[],"length":0,"stats":{"Line":14}},{"line":460,"address":[],"length":0,"stats":{"Line":14}},{"line":461,"address":[],"length":0,"stats":{"Line":42}},{"line":462,"address":[],"length":0,"stats":{"Line":14}},{"line":482,"address":[],"length":0,"stats":{"Line":14}},{"line":483,"address":[],"length":0,"stats":{"Line":28}},{"line":484,"address":[],"length":0,"stats":{"Line":28}},{"line":493,"address":[],"length":0,"stats":{"Line":14}},{"line":494,"address":[],"length":0,"stats":{"Line":28}},{"line":495,"address":[],"length":0,"stats":{"Line":28}},{"line":504,"address":[],"length":0,"stats":{"Line":14}},{"line":505,"address":[],"length":0,"stats":{"Line":28}},{"line":506,"address":[],"length":0,"stats":{"Line":28}},{"line":515,"address":[],"length":0,"stats":{"Line":15}},{"line":516,"address":[],"length":0,"stats":{"Line":45}},{"line":517,"address":[],"length":0,"stats":{"Line":15}},{"line":530,"address":[],"length":0,"stats":{"Line":18}},{"line":531,"address":[],"length":0,"stats":{"Line":36}},{"line":532,"address":[],"length":0,"stats":{"Line":54}},{"line":543,"address":[],"length":0,"stats":{"Line":14}},{"line":544,"address":[],"length":0,"stats":{"Line":28}},{"line":545,"address":[],"length":0,"stats":{"Line":42}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":15}},{"line":625,"address":[],"length":0,"stats":{"Line":15}},{"line":626,"address":[],"length":0,"stats":{"Line":30}},{"line":627,"address":[],"length":0,"stats":{"Line":14}},{"line":629,"address":[],"length":0,"stats":{"Line":24}},{"line":641,"address":[],"length":0,"stats":{"Line":8}},{"line":642,"address":[],"length":0,"stats":{"Line":16}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":8}},{"line":658,"address":[],"length":0,"stats":{"Line":14}},{"line":661,"address":[],"length":0,"stats":{"Line":14}},{"line":662,"address":[],"length":0,"stats":{"Line":28}},{"line":663,"address":[],"length":0,"stats":{"Line":14}},{"line":665,"address":[],"length":0,"stats":{"Line":7}},{"line":689,"address":[],"length":0,"stats":{"Line":14}},{"line":690,"address":[],"length":0,"stats":{"Line":28}},{"line":691,"address":[],"length":0,"stats":{"Line":28}},{"line":702,"address":[],"length":0,"stats":{"Line":14}},{"line":703,"address":[],"length":0,"stats":{"Line":28}},{"line":704,"address":[],"length":0,"stats":{"Line":28}},{"line":715,"address":[],"length":0,"stats":{"Line":14}},{"line":716,"address":[],"length":0,"stats":{"Line":28}},{"line":717,"address":[],"length":0,"stats":{"Line":28}},{"line":751,"address":[],"length":0,"stats":{"Line":4}},{"line":752,"address":[],"length":0,"stats":{"Line":4}},{"line":753,"address":[],"length":0,"stats":{"Line":8}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":4}},{"line":769,"address":[],"length":0,"stats":{"Line":4}},{"line":770,"address":[],"length":0,"stats":{"Line":4}},{"line":771,"address":[],"length":0,"stats":{"Line":8}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":4}},{"line":786,"address":[],"length":0,"stats":{"Line":56}},{"line":791,"address":[],"length":0,"stats":{"Line":56}},{"line":795,"address":[],"length":0,"stats":{"Line":112}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":14}},{"line":818,"address":[],"length":0,"stats":{"Line":28}},{"line":827,"address":[],"length":0,"stats":{"Line":14}},{"line":832,"address":[],"length":0,"stats":{"Line":14}},{"line":833,"address":[],"length":0,"stats":{"Line":14}},{"line":834,"address":[],"length":0,"stats":{"Line":28}},{"line":835,"address":[],"length":0,"stats":{"Line":42}},{"line":836,"address":[],"length":0,"stats":{"Line":14}},{"line":837,"address":[],"length":0,"stats":{"Line":28}},{"line":838,"address":[],"length":0,"stats":{"Line":7}},{"line":840,"address":[],"length":0,"stats":{"Line":42}},{"line":841,"address":[],"length":0,"stats":{"Line":14}},{"line":842,"address":[],"length":0,"stats":{"Line":28}},{"line":843,"address":[],"length":0,"stats":{"Line":7}},{"line":850,"address":[],"length":0,"stats":{"Line":14}},{"line":851,"address":[],"length":0,"stats":{"Line":70}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":14}},{"line":889,"address":[],"length":0,"stats":{"Line":42}},{"line":897,"address":[],"length":0,"stats":{"Line":14}},{"line":902,"address":[],"length":0,"stats":{"Line":14}},{"line":903,"address":[],"length":0,"stats":{"Line":14}},{"line":904,"address":[],"length":0,"stats":{"Line":28}},{"line":905,"address":[],"length":0,"stats":{"Line":49}},{"line":906,"address":[],"length":0,"stats":{"Line":14}},{"line":907,"address":[],"length":0,"stats":{"Line":28}},{"line":908,"address":[],"length":0,"stats":{"Line":7}},{"line":910,"address":[],"length":0,"stats":{"Line":49}},{"line":911,"address":[],"length":0,"stats":{"Line":14}},{"line":912,"address":[],"length":0,"stats":{"Line":28}},{"line":913,"address":[],"length":0,"stats":{"Line":7}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":14}},{"line":956,"address":[],"length":0,"stats":{"Line":14}},{"line":957,"address":[],"length":0,"stats":{"Line":28}},{"line":958,"address":[],"length":0,"stats":{"Line":98}},{"line":959,"address":[],"length":0,"stats":{"Line":14}},{"line":960,"address":[],"length":0,"stats":{"Line":28}},{"line":961,"address":[],"length":0,"stats":{"Line":14}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":14}},{"line":993,"address":[],"length":0,"stats":{"Line":14}},{"line":994,"address":[],"length":0,"stats":{"Line":14}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":14}},{"line":1022,"address":[],"length":0,"stats":{"Line":14}},{"line":1036,"address":[],"length":0,"stats":{"Line":14}},{"line":1037,"address":[],"length":0,"stats":{"Line":14}},{"line":1063,"address":[],"length":0,"stats":{"Line":8}},{"line":1065,"address":[],"length":0,"stats":{"Line":16}},{"line":1066,"address":[],"length":0,"stats":{"Line":16}}],"covered":189,"coverable":244},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","src","lib.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n#![cfg_attr(feature = \"offset_of_enum\", feature(offset_of_enum))]\n#![doc = include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/README.md\"))]\n#![deny(unconditional_recursion)]\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#[cfg(not(feature = \"std\"))]\nextern crate alloc;\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::string::String;\n\n#[cfg(feature = \"derive\")]\npub use mem_dbg_derive::{MemDbg, MemSize};\n\nmod impl_mem_dbg;\nmod impl_mem_size;\n\nmod utils;\npub use utils::*;\n\n/**\n\nInternal trait used within [`CopyType`] to implement [`MemSize`] depending\non whether a type is [`Copy`] or not.\n\nIt has only two implementations, [`True`] and [`False`].\n\n*/\npub trait Boolean {}\n/// One of the two possible implementations of [`Boolean`].\npub struct True {}\nimpl Boolean for True {}\n/// One of the two possible implementations of [`Boolean`].\npub struct False {}\nimpl Boolean for False {}\n\n/**\n\nMarker trait for copy types.\n\nThe trait comes in two flavors: `CopyType\u003cCopy=True\u003e` and\n`CopyType\u003cCopy=False\u003e`. In the first case, [`MemSize::mem_size`] can be computed on\narrays, vectors, and slices by multiplying the length or capacity\nby the size of the element type; in the second case, it\nis necessary to iterate on each element.\n\nThe trait is made necessary by the impossibility of checking that a type\nimplements [`Copy`] from a procedural macro.\n\nSince we cannot use negative trait bounds, every type that is used as a parameter of\nan array, vector, or slice must implement either `CopyType\u003cCopy=True\u003e` or\n`CopyType\u003cCopy=False\u003e`.  If you do not implement either of these traits,\nyou will not be able to compute the size of arrays, vectors, and slices but error\nmessages will be very unhelpful due to the contrived way we have to implement\nmutually exclusive types [working around the bug that prevents the compiler\nfrom understanding that implementations for the two flavors of `CopyType` are mutually\nexclusive](https://github.com/rust-lang/rfcs/pull/1672#issuecomment-1405377983).\n\nIf you use the provided derive macros all this logic will be hidden from you. You'll\njust have to add the attribute `#[copy_type]` to your structures if they\nare [`Copy`] types and they do not contain non-`'static` references. We enforce this property by\nadding a bound `Copy + 'static` to the type in the procedural macro.\n\nNote that this approach forces us to compute the size of [`Copy`] types that contain\nreferences by iteration _even if you do not specify_ [`SizeFlags::FOLLOW_REFS`].\n\n*/\npub trait CopyType {\n    type Copy: Boolean;\n}\n\nbitflags::bitflags! {\n    /// Flags for [`MemDbg`].\n    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct SizeFlags: u32 {\n        /// Follow references.\n        ///\n        /// By default [`MemSize::mem_size`] does not follow references and\n        /// computes only the size of the reference itself.\n        ///\n        /// # Warning\n        ///\n        /// Note that all references are followed independently. If the same\n        /// region of memory is reachable by two different paths, it will be\n        /// counted twice.\n        const FOLLOW_REFS = 1 \u003c\u003c 0;\n        /// Return capacity instead of size.\n        ///\n        /// Size does not include memory allocated but not used: for example, in\n        /// the case of a vector [`MemSize::mem_size`] calls [`Vec::len`] rather\n        /// than [`Vec::capacity`].\n        ///\n        /// However, when this flag is specified [`MemSize::mem_size`] will\n        /// return the size of all memory allocated, even if it is not used: for\n        /// example, in the case of a vector this option makes\n        /// [`MemSize::mem_size`] call [`Vec::capacity`] rather than\n        /// [`Vec::len`].\n        const CAPACITY = 1 \u003c\u003c 1;\n    }\n}\n\nimpl Default for SizeFlags {\n    /// The default set of flags is the empty set.\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::empty()\n    }\n}\n\n/// A trait to compute recursively the overall size or capacity of a structure,\n/// as opposed to the stack size returned by [`core::mem::size_of()`].\n///\n/// You can derive this trait with `#[derive(MemSize)]` if all the fields of\n/// your type implement [`MemSize`].\npub trait MemSize {\n    /// Returns the (recursively computed) overall\n    /// memory size of the structure in bytes.\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize;\n}\n\nbitflags::bitflags! {\n    /// Flags for [`MemDbg`].\n    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct DbgFlags: u32 {\n        /// Follow references. See [`SizeFlags::FOLLOW_REFS`].\n        const FOLLOW_REFS = 1 \u003c\u003c 0;\n        /// Print memory usage in human readable format.\n        const HUMANIZE = 1 \u003c\u003c 1;\n        /// Print memory usage as a percentage.\n        const PERCENTAGE = 1 \u003c\u003c 2;\n        /// Print the type name.\n        const TYPE_NAME = 1 \u003c\u003c 3;\n        /// Display capacity instead of size. See [`SizeFlags::CAPACITY`].\n        const CAPACITY = 1 \u003c\u003c 4;\n        /// Add an underscore every 3 digits, when `HUMANIZE` is not set.\n        const SEPARATOR = 1 \u003c\u003c 5;\n        /// Print fields in memory order (i.e., using the layout chosen by the\n        /// compiler), rather than in declaration order.\n        const RUST_LAYOUT = 1 \u003c\u003c 6;\n        /// Use colors to distinguish sizes.\n        const COLOR = 1 \u003c\u003c 7;\n    }\n}\n\nimpl DbgFlags {\n    /// Translates flags that are in common with [`MemSize`] into [`SizeFlags`].\n    pub fn to_size_flags(\u0026self) -\u003e SizeFlags {\n        let mut flags = SizeFlags::empty();\n        if self.contains(DbgFlags::FOLLOW_REFS) {\n            flags |= SizeFlags::FOLLOW_REFS;\n        }\n        if self.contains(DbgFlags::CAPACITY) {\n            flags |= SizeFlags::CAPACITY;\n        }\n        flags\n    }\n}\n\nimpl Default for DbgFlags {\n    /// The default set of flags contains [`DbgFlags::TYPE_NAME`],\n    /// [`DbgFlags::SEPARATOR`], and [`DbgFlags::PERCENTAGE`].\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::TYPE_NAME | Self::SEPARATOR | Self::PERCENTAGE\n    }\n}\n\n/// A trait providing methods to display recursively the content and size of a\n/// structure.\n///\n/// You can derive this trait with `#[derive(MemDbg)]` if all the fields of your\n/// type implement [`MemDbg`]. Note that you will also need to derive\n/// [`MemSize`].\npub trait MemDbg: MemDbgImpl {\n    /// Writes to stderr debug infos about the structure memory usage, expanding\n    /// all levels of nested structures.\n    #[inline(always)]\n    #[cfg(feature = \"std\")]\n    fn mem_dbg(\u0026self, flags: DbgFlags) -\u003e core::fmt::Result {\n        // TODO: fix padding\n        self._mem_dbg_depth(\n            \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags()),\n            usize::MAX,\n            core::mem::size_of_val(self),\n            flags,\n        )\n    }\n\n    /// Writes to a [`core::fmt::Write`] debug infos about the structure memory\n    /// usage, expanding all levels of nested structures.\n    #[inline(always)]\n    fn mem_dbg_on(\u0026self, writer: \u0026mut impl core::fmt::Write, flags: DbgFlags) -\u003e core::fmt::Result {\n        // TODO: fix padding\n        self._mem_dbg_depth_on(\n            writer,\n            \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags()),\n            usize::MAX,\n            \u0026mut String::new(),\n            Some(\"\"),\n            true,\n            core::mem::size_of_val(self),\n            flags,\n        )\n    }\n\n    #[cfg(feature = \"std\")]\n    /// Writes to stderr debug infos about the structure memory usage as\n    /// [`mem_dbg`](MemDbg::mem_dbg), but expanding only up to `max_depth`\n    /// levels of nested structures.\n    fn mem_dbg_depth(\u0026self, max_depth: usize, flags: DbgFlags) -\u003e core::fmt::Result {\n        self._mem_dbg_depth(\n            \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags()),\n            max_depth,\n            core::mem::size_of_val(self),\n            flags,\n        )\n    }\n\n    /// Writes to a [`core::fmt::Write`] debug infos about the structure memory\n    /// usage as [`mem_dbg_on`](MemDbg::mem_dbg_on), but expanding only up to\n    /// `max_depth` levels of nested structures.\n    fn mem_dbg_depth_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        max_depth: usize,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self._mem_dbg_depth_on(\n            writer,\n            \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags()),\n            max_depth,\n            \u0026mut String::new(),\n            None,\n            false,\n            core::mem::size_of_val(self),\n            flags,\n        )\n    }\n}\n\n/// Implemens [`MemDbg`] for all types that implement [`MemDbgImpl`].\n///\n/// This is done so that no one can change the implementation of [`MemDbg`],\n/// which ensures consistency in printing.\nimpl\u003cT: MemDbgImpl\u003e MemDbg for T {}\n\n/// Inner trait used to implement [`MemDbg`].\n///\n/// This trait should not be implemented by users, which should use the\n/// [`MemDbg`](mem_dbg_derive::MemDbg) derive macro instead.\n///\n/// The default no-op implementation is used by all types in which it does not\n/// make sense, or it is impossible, to recurse.\npub trait MemDbgImpl: MemSize {\n    #[inline(always)]\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        _writer: \u0026mut impl core::fmt::Write,\n        _total_size: usize,\n        _max_depth: usize,\n        _prefix: \u0026mut String,\n        _is_last: bool,\n        _flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        Ok(())\n    }\n\n    #[cfg(feature = \"std\")]\n    #[doc(hidden)]\n    #[inline(always)]\n    fn _mem_dbg_depth(\n        \u0026self,\n        total_size: usize,\n        max_depth: usize,\n        padded_size: usize,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        struct Wrapper(std::io::Stderr);\n        impl core::fmt::Write for Wrapper {\n            #[inline(always)]\n            fn write_str(\u0026mut self, s: \u0026str) -\u003e core::fmt::Result {\n                use std::io::Write;\n                self.0\n                    .lock()\n                    .write(s.as_bytes())\n                    .map_err(|_| core::fmt::Error)\n                    .map(|_| ())\n            }\n        }\n        self._mem_dbg_depth_on(\n            \u0026mut Wrapper(std::io::stderr()),\n            total_size,\n            max_depth,\n            \u0026mut String::new(),\n            Some(\"\"),\n            true,\n            padded_size,\n            flags,\n        )\n    }\n\n    #[inline(always)]\n    #[allow(clippy::too_many_arguments)]\n    fn _mem_dbg_depth_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        field_name: Option\u003c\u0026str\u003e,\n        is_last: bool,\n        padded_size: usize,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        if prefix.len() \u003e max_depth {\n            return Ok(());\n        }\n        let real_size = \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags());\n        if flags.contains(DbgFlags::COLOR) {\n            let color = utils::color(real_size);\n            writer.write_fmt(format_args!(\"{color}\"))?;\n        };\n        if flags.contains(DbgFlags::HUMANIZE) {\n            let (value, uom) = crate::utils::humanize_float(real_size as f64);\n            if uom == \" B\" {\n                writer.write_fmt(format_args!(\"{:\u003e5}  B \", real_size))?;\n            } else {\n                let mut precision = 4;\n                let a = if value \u003c 0.0 { -value } else { value };\n                if a \u003e= 100.0 {\n                    precision = 1;\n                } else if a \u003e= 10.0 {\n                    precision = 2;\n                } else if a \u003e= 1.0 {\n                    precision = 3;\n                }\n                writer.write_fmt(format_args!(\"{0:\u003e4.1$} {2} \", value, precision, uom))?;\n            }\n        } else if flags.contains(DbgFlags::SEPARATOR) {\n            let mut align = crate::utils::n_of_digits(total_size);\n            let mut real_size = real_size;\n            align += align / 3;\n            let mut digits = crate::utils::n_of_digits(real_size);\n            let digit_align = digits + digits / 3;\n            for _ in digit_align..align {\n                writer.write_char(' ')?;\n            }\n\n            let first_digits = digits % 3;\n            let mut multiplier = 10_usize.pow((digits - first_digits) as u32);\n            if first_digits != 0 {\n                writer.write_fmt(format_args!(\"{}\", real_size / multiplier))?;\n            } else {\n                multiplier /= 1000;\n                digits -= 3;\n                writer.write_fmt(format_args!(\" {}\", real_size / multiplier))?;\n            }\n\n            while digits \u003e= 3 {\n                real_size %= multiplier;\n                multiplier /= 1000;\n                writer.write_fmt(format_args!(\"_{:03}\", real_size / multiplier))?;\n                digits -= 3;\n            }\n\n            writer.write_str(\" B \")?;\n        } else {\n            let align = crate::utils::n_of_digits(total_size);\n            writer.write_fmt(format_args!(\"{:\u003ealign$} B \", real_size, align = align))?;\n        }\n\n        if flags.contains(DbgFlags::PERCENTAGE) {\n            writer.write_fmt(format_args!(\n                \"{:\u003e6.2}% \",\n                if total_size == 0 {\n                    100.0\n                } else {\n                    100.0 * real_size as f64 / total_size as f64\n                }\n            ))?;\n        }\n        if flags.contains(DbgFlags::COLOR) {\n            let reset_color = utils::reset_color();\n            writer.write_fmt(format_args!(\"{reset_color}\"))?;\n        };\n        if !prefix.is_empty() {\n            writer.write_str(\u0026prefix[2..])?;\n            if is_last {\n                writer.write_char('')?;\n            } else {\n                writer.write_char('')?;\n            }\n            writer.write_char('')?;\n        }\n\n        if let Some(field_name) = field_name {\n            writer.write_fmt(format_args!(\"{:}\", field_name))?;\n        }\n\n        if flags.contains(DbgFlags::TYPE_NAME) {\n            if flags.contains(DbgFlags::COLOR) {\n                writer.write_fmt(format_args!(\"{}\", utils::type_color()))?;\n            }\n            writer.write_fmt(format_args!(\": {:}\", core::any::type_name::\u003cSelf\u003e()))?;\n            if flags.contains(DbgFlags::COLOR) {\n                writer.write_fmt(format_args!(\"{}\", utils::reset_color()))?;\n            }\n        }\n\n        //dbg!(padded_size, core::mem::size_of_val(self));\n        let padding = padded_size - core::mem::size_of_val(self);\n\n        if padding != 0 {\n            writer.write_fmt(format_args!(\" [{}B]\", padding))?;\n        }\n\n        writer.write_char('\\n')?;\n\n        if is_last {\n            prefix.push_str(\"  \");\n        } else {\n            prefix.push_str(\" \");\n        }\n\n        self._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)?;\n\n        prefix.pop();\n        prefix.pop();\n\n        Ok(())\n    }\n}\n","traces":[{"line":111,"address":[],"length":0,"stats":{"Line":180}},{"line":112,"address":[],"length":0,"stats":{"Line":180}},{"line":153,"address":[],"length":0,"stats":{"Line":402}},{"line":154,"address":[],"length":0,"stats":{"Line":804}},{"line":155,"address":[],"length":0,"stats":{"Line":804}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":984}},{"line":159,"address":[],"length":0,"stats":{"Line":180}},{"line":161,"address":[],"length":0,"stats":{"Line":402}},{"line":169,"address":[],"length":0,"stats":{"Line":13}},{"line":170,"address":[],"length":0,"stats":{"Line":13}},{"line":185,"address":[],"length":0,"stats":{"Line":14}},{"line":187,"address":[],"length":0,"stats":{"Line":28}},{"line":188,"address":[],"length":0,"stats":{"Line":56}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":28}},{"line":191,"address":[],"length":0,"stats":{"Line":14}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":288}},{"line":271,"address":[],"length":0,"stats":{"Line":288}},{"line":277,"address":[],"length":0,"stats":{"Line":14}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":527}},{"line":289,"address":[],"length":0,"stats":{"Line":527}},{"line":291,"address":[],"length":0,"stats":{"Line":1054}},{"line":292,"address":[],"length":0,"stats":{"Line":527}},{"line":293,"address":[],"length":0,"stats":{"Line":527}},{"line":296,"address":[],"length":0,"stats":{"Line":28}},{"line":297,"address":[],"length":0,"stats":{"Line":14}},{"line":298,"address":[],"length":0,"stats":{"Line":14}},{"line":299,"address":[],"length":0,"stats":{"Line":14}},{"line":300,"address":[],"length":0,"stats":{"Line":14}},{"line":301,"address":[],"length":0,"stats":{"Line":14}},{"line":303,"address":[],"length":0,"stats":{"Line":14}},{"line":304,"address":[],"length":0,"stats":{"Line":14}},{"line":310,"address":[],"length":0,"stats":{"Line":352}},{"line":321,"address":[],"length":0,"stats":{"Line":704}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":1760}},{"line":325,"address":[],"length":0,"stats":{"Line":704}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":704}},{"line":330,"address":[],"length":0,"stats":{"Line":480}},{"line":331,"address":[],"length":0,"stats":{"Line":160}},{"line":332,"address":[],"length":0,"stats":{"Line":474}},{"line":334,"address":[],"length":0,"stats":{"Line":4}},{"line":335,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":6}},{"line":345,"address":[],"length":0,"stats":{"Line":384}},{"line":346,"address":[],"length":0,"stats":{"Line":576}},{"line":347,"address":[],"length":0,"stats":{"Line":384}},{"line":348,"address":[],"length":0,"stats":{"Line":192}},{"line":349,"address":[],"length":0,"stats":{"Line":576}},{"line":350,"address":[],"length":0,"stats":{"Line":384}},{"line":351,"address":[],"length":0,"stats":{"Line":192}},{"line":352,"address":[],"length":0,"stats":{"Line":1224}},{"line":355,"address":[],"length":0,"stats":{"Line":384}},{"line":356,"address":[],"length":0,"stats":{"Line":576}},{"line":357,"address":[],"length":0,"stats":{"Line":192}},{"line":358,"address":[],"length":0,"stats":{"Line":732}},{"line":360,"address":[],"length":0,"stats":{"Line":9}},{"line":361,"address":[],"length":0,"stats":{"Line":9}},{"line":362,"address":[],"length":0,"stats":{"Line":36}},{"line":365,"address":[],"length":0,"stats":{"Line":195}},{"line":366,"address":[],"length":0,"stats":{"Line":3}},{"line":367,"address":[],"length":0,"stats":{"Line":3}},{"line":368,"address":[],"length":0,"stats":{"Line":12}},{"line":369,"address":[],"length":0,"stats":{"Line":3}},{"line":372,"address":[],"length":0,"stats":{"Line":576}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":704}},{"line":379,"address":[],"length":0,"stats":{"Line":1056}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":352}},{"line":382,"address":[],"length":0,"stats":{"Line":3}},{"line":384,"address":[],"length":0,"stats":{"Line":349}},{"line":388,"address":[],"length":0,"stats":{"Line":704}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":352}},{"line":393,"address":[],"length":0,"stats":{"Line":1014}},{"line":394,"address":[],"length":0,"stats":{"Line":338}},{"line":395,"address":[],"length":0,"stats":{"Line":22}},{"line":397,"address":[],"length":0,"stats":{"Line":654}},{"line":399,"address":[],"length":0,"stats":{"Line":676}},{"line":402,"address":[],"length":0,"stats":{"Line":704}},{"line":403,"address":[],"length":0,"stats":{"Line":1056}},{"line":406,"address":[],"length":0,"stats":{"Line":704}},{"line":407,"address":[],"length":0,"stats":{"Line":704}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":1408}},{"line":411,"address":[],"length":0,"stats":{"Line":704}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":1056}},{"line":419,"address":[],"length":0,"stats":{"Line":352}},{"line":420,"address":[],"length":0,"stats":{"Line":15}},{"line":423,"address":[],"length":0,"stats":{"Line":704}},{"line":425,"address":[],"length":0,"stats":{"Line":377}},{"line":426,"address":[],"length":0,"stats":{"Line":50}},{"line":428,"address":[],"length":0,"stats":{"Line":654}},{"line":431,"address":[],"length":0,"stats":{"Line":2816}},{"line":433,"address":[],"length":0,"stats":{"Line":704}},{"line":434,"address":[],"length":0,"stats":{"Line":704}},{"line":436,"address":[],"length":0,"stats":{"Line":352}}],"covered":95,"coverable":135},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","src","utils.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n/// Given a float, returns it in a human readable format using SI suffixes.\npub fn humanize_float(mut x: f64) -\u003e (f64, \u0026'static str) {\n    const UOM: \u0026[\u0026str] = \u0026[\n        \"qB\", \"rB\", \"yB\", \"zB\", \"aB\", \"fB\", \"pB\", \"nB\", \"B\", \"mB\", \" B\", \"kB\", \"MB\", \"GB\", \"TB\",\n        \"PB\", \"EB\", \"ZB\", \"YB\", \"RB\", \"QB\",\n    ];\n    let mut uom_idx = 10;\n    debug_assert_eq!(UOM[uom_idx], \" B\");\n\n    if x == 0.0 {\n        return (0.0, UOM[uom_idx]);\n    }\n\n    let abs_x = if x \u003c 0.0 { -x } else { x };\n\n    if abs_x \u003e 1.0 {\n        while abs_x \u003e 1000.0 \u0026\u0026 uom_idx \u003c UOM.len() - 1 {\n            uom_idx += 1;\n            x /= 1000.0;\n        }\n    } else {\n        while abs_x \u003c 0.001 \u0026\u0026 uom_idx \u003e 0 {\n            uom_idx -= 1;\n            x *= 1000.0;\n        }\n    }\n\n    (x, UOM[uom_idx])\n}\n\npub fn color(x: usize) -\u003e \u0026'static str {\n    const KB: usize = 1024;\n    const MB: usize = KB * KB;\n    const GB: usize = MB * KB;\n    #[allow(clippy::match_overlapping_arm)]\n    match x {\n        // white\n        ..KB =\u003e reset_color(),\n        // green\n        ..MB =\u003e \"\\x1B[32m\",\n        // yellow\n        ..GB =\u003e \"\\x1B[33m\",\n        // red\n        _ =\u003e \"\\x1B[31m\",\n    }\n}\n\npub fn type_color() -\u003e \u0026'static str {\n    // custom grey\n    \"\\x1B[38;2;128;128;128m\"\n}\n\npub fn reset_color() -\u003e \u0026'static str {\n    \"\\x1B[0m\"\n}\n\n/// Returns the number of digits of a number.\n///\n/// ```\n/// use mem_dbg::n_of_digits;\n///\n/// assert_eq!(n_of_digits(0), 1);\n/// assert_eq!(n_of_digits(1), 1);\n/// assert_eq!(n_of_digits(10), 2);\n/// assert_eq!(n_of_digits(100), 3);\n/// assert_eq!(n_of_digits(1000), 4);\n/// assert_eq!(n_of_digits(10000), 5);\n/// assert_eq!(n_of_digits(100000), 6);\n/// ```\npub fn n_of_digits(x: usize) -\u003e usize {\n    if x == 0 {\n        return 1;\n    }\n    let mut digits = 0;\n    let mut x = x;\n    while x \u003e 0 {\n        digits += 1;\n        x /= 10;\n    }\n    digits\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":178}},{"line":14,"address":[],"length":0,"stats":{"Line":356}},{"line":15,"address":[],"length":0,"stats":{"Line":356}},{"line":17,"address":[],"length":0,"stats":{"Line":178}},{"line":18,"address":[],"length":0,"stats":{"Line":8}},{"line":21,"address":[],"length":0,"stats":{"Line":510}},{"line":23,"address":[],"length":0,"stats":{"Line":170}},{"line":24,"address":[],"length":0,"stats":{"Line":236}},{"line":25,"address":[],"length":0,"stats":{"Line":20}},{"line":26,"address":[],"length":0,"stats":{"Line":20}},{"line":29,"address":[],"length":0,"stats":{"Line":18}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":340}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":420}},{"line":78,"address":[],"length":0,"stats":{"Line":420}},{"line":79,"address":[],"length":0,"stats":{"Line":14}},{"line":81,"address":[],"length":0,"stats":{"Line":812}},{"line":82,"address":[],"length":0,"stats":{"Line":812}},{"line":83,"address":[],"length":0,"stats":{"Line":2596}},{"line":84,"address":[],"length":0,"stats":{"Line":1095}},{"line":85,"address":[],"length":0,"stats":{"Line":1095}},{"line":87,"address":[],"length":0,"stats":{"Line":406}}],"covered":21,"coverable":33},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_comprehensive_mem_dbg.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2025 Inria\n * SPDX-FileCopyrightText: 2025 Tommaso Fontana\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n//! Comprehensive test for MemDbg that includes all types in the crate\n//! that implement the necessary traits.\n\n#![cfg(feature = \"std\")]\n#![cfg(feature = \"derive\")]\n\nuse mem_dbg::*;\nuse std::collections::{HashMap, HashSet};\nuse std::collections::hash_map::{RandomState, DefaultHasher};\nuse std::hash::BuildHasherDefault;\nuse std::sync::{Arc, Mutex, RwLock};\nuse core::sync::atomic::*;\nuse core::num::*;\nuse core::marker::{PhantomData, PhantomPinned};\nuse core::cell::{Cell, RefCell, UnsafeCell, OnceCell};\nuse core::ops::*;\nuse core::ptr::NonNull;\nuse core::alloc::Layout;\nuse std::path::PathBuf;\nuse std::ffi::OsString;\nuse std::io::{BufReader, BufWriter, Cursor};\nuse std::fs::File;\n\n// Static data for references\nstatic STATIC_STR: \u0026str = \"static string\";\n\n#[derive(MemSize, MemDbg)]\nstruct ComprehensiveStruct {\n    // Primitive types\n    unit: (),\n    boolean: bool,\n    character: char,\n    float32: f32,\n    float64: f64,\n    \n    // Unsigned integers\n    u8_val: u8,\n    u16_val: u16,\n    u32_val: u32,\n    u64_val: u64,\n    u128_val: u128,\n    usize_val: usize,\n    \n    // Signed integers\n    i8_val: i8,\n    i16_val: i16,\n    i32_val: i32,\n    i64_val: i64,\n    i128_val: i128,\n    isize_val: isize,\n    \n    // Atomic types\n    atomic_bool: AtomicBool,\n    atomic_i8: AtomicI8,\n    atomic_i16: AtomicI16,\n    atomic_i32: AtomicI32,\n    atomic_i64: AtomicI64,\n    atomic_isize: AtomicIsize,\n    atomic_u8: AtomicU8,\n    atomic_u16: AtomicU16,\n    atomic_u32: AtomicU32,\n    atomic_u64: AtomicU64,\n    atomic_usize: AtomicUsize,\n    \n    // NonZero types\n    nonzero_i8: NonZeroI8,\n    nonzero_i16: NonZeroI16,\n    nonzero_i32: NonZeroI32,\n    nonzero_i64: NonZeroI64,\n    nonzero_i128: NonZeroI128,\n    nonzero_isize: NonZeroIsize,\n    nonzero_u8: NonZeroU8,\n    nonzero_u16: NonZeroU16,\n    nonzero_u32: NonZeroU32,\n    nonzero_u64: NonZeroU64,\n    nonzero_u128: NonZeroU128,\n    nonzero_usize: NonZeroUsize,\n    \n    // Phantom types\n    phantom_pinned: PhantomPinned,\n    phantom_data: PhantomData\u003ci32\u003e,\n    \n    // String types\n    string: String,\n    \n    // Option\n    option_some: Option\u003ci32\u003e,\n    option_none: Option\u003ci32\u003e,\n    \n    // Box\n    boxed: Box\u003cu64\u003e,\n    \n    // Arc\n    arc: Arc\u003ci32\u003e,\n    \n    // Vec and arrays\n    vec_values: Vec\u003ci32\u003e,\n    array: [u8; 10],\n    \n    // Tuples\n    tuple2: (i32, String),\n    tuple3: (i32, String, f64),\n    tuple4: (i32, String, f64, bool),\n    \n    // Hash collections\n    hash_set: HashSet\u003ci32\u003e,\n    hash_map: HashMap\u003cString, i32\u003e,\n    \n    // Ranges\n    range: Range\u003cusize\u003e,\n    range_from: RangeFrom\u003cusize\u003e,\n    range_inclusive: RangeInclusive\u003cusize\u003e,\n    range_to: RangeTo\u003cusize\u003e,\n    range_to_inclusive: RangeToInclusive\u003cusize\u003e,\n    \n    // Cells\n    ref_cell: RefCell\u003ci32\u003e,\n    cell: Cell\u003ci32\u003e,\n    unsafe_cell: UnsafeCell\u003ci32\u003e,\n    once_cell: OnceCell\u003cString\u003e,\n    \n    // Synchronization primitives\n    mutex: Mutex\u003ci32\u003e,\n    rw_lock: RwLock\u003cString\u003e,\n    \n    // Path types\n    path_buf: PathBuf,\n    os_string: OsString,\n    \n    // References\n    reference: \u0026'static str,\n    mut_reference: \u0026'static mut i32,\n    \n    // Function pointers\n    fn_ptr0: fn() -\u003e i32,\n    fn_ptr1: fn(i32) -\u003e i32,\n    fn_ptr2: fn(i32, i32) -\u003e i32,\n    \n    // Hash builders\n    build_hasher: BuildHasherDefault\u003cDefaultHasher\u003e,\n    random_state: RandomState,\n    \n    // Layout\n    layout: Layout,\n    \n    // NonNull pointer\n    non_null: NonNull\u003ci32\u003e,\n    \n    // I/O wrappers\n    buf_reader: BufReader\u003cFile\u003e,\n    buf_writer: BufWriter\u003cFile\u003e,\n    cursor: Cursor\u003cVec\u003cu8\u003e\u003e,\n}\n\n#[test]\nfn test_comprehensive_mem_dbg() {\n    // Create leaked references for the test\n    let leaked_mut: \u0026'static mut i32 = Box::leak(Box::new(999));\n    let leaked_for_nonnull: \u0026'static mut i32 = Box::leak(Box::new(888));\n    \n    let mut hash_set = HashSet::new();\n    hash_set.insert(1);\n    hash_set.insert(2);\n    hash_set.insert(3);\n    \n    let mut hash_map = HashMap::new();\n    hash_map.insert(\"key1\".to_string(), 100);\n    hash_map.insert(\"key2\".to_string(), 200);\n    \n    let once_cell = OnceCell::new();\n    once_cell.set(\"initialized\".to_string()).unwrap();\n    \n    let comprehensive = ComprehensiveStruct {\n        // Primitives\n        unit: (),\n        boolean: true,\n        character: 'A',\n        float32: 3.14,\n        float64: 2.718,\n        \n        // Unsigned integers\n        u8_val: 8,\n        u16_val: 16,\n        u32_val: 32,\n        u64_val: 64,\n        u128_val: 128,\n        usize_val: 1024,\n        \n        // Signed integers\n        i8_val: -8,\n        i16_val: -16,\n        i32_val: -32,\n        i64_val: -64,\n        i128_val: -128,\n        isize_val: -1024,\n        \n        // Atomics\n        atomic_bool: AtomicBool::new(true),\n        atomic_i8: AtomicI8::new(8),\n        atomic_i16: AtomicI16::new(16),\n        atomic_i32: AtomicI32::new(32),\n        atomic_i64: AtomicI64::new(64),\n        atomic_isize: AtomicIsize::new(1024),\n        atomic_u8: AtomicU8::new(8),\n        atomic_u16: AtomicU16::new(16),\n        atomic_u32: AtomicU32::new(32),\n        atomic_u64: AtomicU64::new(64),\n        atomic_usize: AtomicUsize::new(1024),\n        \n        // NonZero types\n        nonzero_i8: NonZeroI8::new(1).unwrap(),\n        nonzero_i16: NonZeroI16::new(1).unwrap(),\n        nonzero_i32: NonZeroI32::new(1).unwrap(),\n        nonzero_i64: NonZeroI64::new(1).unwrap(),\n        nonzero_i128: NonZeroI128::new(1).unwrap(),\n        nonzero_isize: NonZeroIsize::new(1).unwrap(),\n        nonzero_u8: NonZeroU8::new(1).unwrap(),\n        nonzero_u16: NonZeroU16::new(1).unwrap(),\n        nonzero_u32: NonZeroU32::new(1).unwrap(),\n        nonzero_u64: NonZeroU64::new(1).unwrap(),\n        nonzero_u128: NonZeroU128::new(1).unwrap(),\n        nonzero_usize: NonZeroUsize::new(1).unwrap(),\n        \n        // Phantoms\n        phantom_pinned: PhantomPinned,\n        phantom_data: PhantomData,\n        \n        // Strings\n        string: \"Hello, world!\".to_string(),\n        \n        // Option\n        option_some: Some(42),\n        option_none: None,\n        \n        // Box\n        boxed: Box::new(12345),\n        \n        // Arc\n        arc: Arc::new(42),\n        \n        // Vec and arrays\n        vec_values: vec![1, 2, 3, 4, 5],\n        array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        \n        // Tuples\n        tuple2: (42, \"answer\".to_string()),\n        tuple3: (1, \"two\".to_string(), 3.0),\n        tuple4: (1, \"two\".to_string(), 3.0, true),\n        \n        // Hash collections\n        hash_set,\n        hash_map,\n        \n        // Ranges\n        range: 0..10,\n        range_from: 5..,\n        range_inclusive: 0..=10,\n        range_to: ..10,\n        range_to_inclusive: ..=10,\n        \n        // Cells\n        ref_cell: RefCell::new(100),\n        cell: Cell::new(200),\n        unsafe_cell: UnsafeCell::new(300),\n        once_cell,\n        \n        // Sync primitives\n        mutex: Mutex::new(400),\n        rw_lock: RwLock::new(\"locked string\".to_string()),\n        \n        // Paths\n        path_buf: PathBuf::from(\"/tmp/test\"),\n        os_string: OsString::from(\"os string\"),\n        \n        // References\n        reference: STATIC_STR,\n        mut_reference: leaked_mut,\n        \n        // Function pointers\n        fn_ptr0: || 42,\n        fn_ptr1: |x| x + 1,\n        fn_ptr2: |x, y| x + y,\n        \n        // Hash builders\n        build_hasher: BuildHasherDefault::\u003cDefaultHasher\u003e::default(),\n        random_state: RandomState::new(),\n        \n        // Layout\n        layout: Layout::from_size_align(128, 8).unwrap(),\n        \n        // NonNull\n        non_null: NonNull::from(leaked_for_nonnull),\n        \n        // I/O wrappers\n        buf_reader: BufReader::new(File::open(\"/dev/null\").unwrap()),\n        buf_writer: BufWriter::new(File::create(\"/tmp/test_comprehensive_buf_writer\").unwrap()),\n        cursor: Cursor::new(vec![1, 2, 3, 4]),\n    };\n    \n    // Test that mem_size works\n    let size = comprehensive.mem_size(SizeFlags::default());\n    assert!(size \u003e 0, \"Size should be greater than 0\");\n    \n    let size_with_capacity = comprehensive.mem_size(SizeFlags::CAPACITY);\n    assert!(size_with_capacity \u003e= size, \"Size with capacity should be \u003e= default size\");\n    \n    // Test that mem_dbg works without errors\n    let result = comprehensive.mem_dbg(DbgFlags::default());\n    assert!(result.is_ok(), \"mem_dbg should succeed: {:?}\", result);\n    \n    // Test with different flags\n    let result = comprehensive.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY);\n    assert!(result.is_ok(), \"mem_dbg with CAPACITY should succeed\");\n    \n    let result = comprehensive.mem_dbg(DbgFlags::default() | DbgFlags::HUMANIZE);\n    assert!(result.is_ok(), \"mem_dbg with HUMANIZE should succeed\");\n    \n    let result = comprehensive.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE);\n    assert!(result.is_ok(), \"mem_dbg with CAPACITY and HUMANIZE should succeed\");\n}\n\n// Test optional features\n#[cfg(feature = \"rand\")]\n#[test]\nfn test_rand_types() {\n    use rand::rngs::{SmallRng, StdRng};\n    use rand::SeedableRng;\n    \n    #[derive(MemSize, MemDbg)]\n    struct RandStruct {\n        small_rng: SmallRng,\n        std_rng: StdRng,\n    }\n    \n    let s = RandStruct {\n        small_rng: SmallRng::seed_from_u64(42),\n        std_rng: StdRng::seed_from_u64(42),\n    };\n    \n    let size = s.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    assert!(s.mem_dbg(DbgFlags::default()).is_ok());\n}\n\n#[cfg(feature = \"half\")]\n#[test]\nfn test_half_types() {\n    use half::{f16, bf16};\n    \n    #[derive(MemSize, MemDbg)]\n    struct HalfStruct {\n        f16_val: f16,\n        bf16_val: bf16,\n    }\n    \n    let s = HalfStruct {\n        f16_val: f16::from_f32(3.14),\n        bf16_val: bf16::from_f32(2.718),\n    };\n    \n    let size = s.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    assert!(s.mem_dbg(DbgFlags::default()).is_ok());\n}\n\n#[cfg(feature = \"maligned\")]\n#[test]\nfn test_maligned_types() {\n    use maligned::{A2, A4, A8, A16, A32, A64, A128, A256, A512, Aligned};\n    \n    #[derive(MemSize, MemDbg)]\n    struct MalignedStruct {\n        a2: A2,\n        a4: A4,\n        a8: A8,\n        a16: A16,\n        a32: A32,\n        a64: A64,\n        a128: A128,\n        a256: A256,\n        a512: A512,\n        aligned_u32: Aligned\u003cA16, u32\u003e,\n        aligned_vec: Aligned\u003cA64, Vec\u003ci32\u003e\u003e,\n    }\n    \n    let s = MalignedStruct {\n        a2: A2::default(),\n        a4: A4::default(),\n        a8: A8::default(),\n        a16: A16::default(),\n        a32: A32::default(),\n        a64: A64::default(),\n        a128: A128::default(),\n        a256: A256::default(),\n        a512: A512::default(),\n        aligned_u32: Aligned::new(42),\n        aligned_vec: Aligned::new(vec![1, 2, 3]),\n    };\n    \n    let size = s.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    assert!(s.mem_dbg(DbgFlags::default()).is_ok());\n}\n\n#[cfg(feature = \"mmap-rs\")]\n#[test]\nfn test_mmap_types() {\n    use mmap_rs::{Mmap, MmapMut, MmapOptions};\n    use std::fs::OpenOptions;\n    \n    #[derive(MemSize, MemDbg)]\n    struct MmapStruct {\n        mmap: Mmap,\n        mmap_mut: MmapMut,\n    }\n    \n    // Create a temp file for mmap\n    let file = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .create(true)\n        .open(\"/tmp/test_mmap_comprehensive\")\n        .unwrap();\n    file.set_len(1024).unwrap();\n    \n    let s = MmapStruct {\n        mmap: unsafe { MmapOptions::new(1024).unwrap().with_file(\u0026file, 0).map().unwrap() },\n        mmap_mut: unsafe { MmapOptions::new(1024).unwrap().with_file(\u0026file, 0).map_mut().unwrap() },\n    };\n    \n    let size = s.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    assert!(s.mem_dbg(DbgFlags::default()).is_ok());\n}\n\n#[test]\nfn test_comprehensive_nested() {\n    #[derive(MemSize, MemDbg)]\n    struct Nested {\n        vec_of_vecs: Vec\u003cVec\u003cString\u003e\u003e,\n        option_box: Option\u003cBox\u003ci32\u003e\u003e,\n        arc_mutex: Arc\u003cMutex\u003cVec\u003ci32\u003e\u003e\u003e,\n    }\n    \n    let nested = Nested {\n        vec_of_vecs: vec![\n            vec![\"a\".to_string(), \"b\".to_string()],\n            vec![\"c\".to_string()],\n        ],\n        option_box: Some(Box::new(999)),\n        arc_mutex: Arc::new(Mutex::new(vec![1, 2, 3])),\n    };\n    \n    let size = nested.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    \n    let result = nested.mem_dbg(DbgFlags::default());\n    assert!(result.is_ok(), \"Nested structure mem_dbg should succeed\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_mem_size.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n#![cfg(feature = \"derive\")]\n#![cfg_attr(feature = \"offset_of_enum\", feature(offset_of_enum))]\n\nuse core::marker::PhantomData;\nuse core::mem::size_of;\nuse mem_dbg::*;\nuse std::sync::atomic::AtomicU64;\n\n#[derive(MemSize)]\n#[cfg_attr(feature = \"std\", derive(MemDbg))]\nunion SingletonUnion\u003cA: Copy\u003e {\n    a: A,\n}\n\n#[allow(dead_code)]\n#[derive(MemSize)]\n#[cfg_attr(feature = \"std\", derive(MemDbg))]\nenum TestEnum {\n    Unit,\n    Unit2(),\n    Unit3 {},\n    Union(SingletonUnion\u003cu8\u003e),\n    Unnamed(usize, u8),\n    Named {\n        first: usize,\n        second: PhantomData\u003cu8\u003e,\n    },\n}\n\n#[test]\nfn test_vec_capacity() {\n    let mut v = vec![Vec::with_capacity(10)];\n    v[0].push(1);\n    v[0].push(2);\n    // We consider the capacity of the inner vector\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY) - v.mem_size(SizeFlags::default()),\n        8 * std::mem::size_of::\u003ci32\u003e()\n    );\n}\n\n#[test]\nfn test_vec_copy_or_not() {\n    #[derive(Clone, MemSize)]\n    #[cfg_attr(feature = \"std\", derive(MemDbg))]\n    struct NewType(usize);\n\n    assert_eq!(\n        vec![NewType(1_usize); 10].mem_size(SizeFlags::default()),\n        vec![1_usize; 10].mem_size(SizeFlags::default())\n    );\n}\n\n#[test]\nfn test_boxed_slice_copy_or_not() {\n    #[derive(Clone, MemSize)]\n    #[cfg_attr(feature = \"std\", derive(MemDbg))]\n    struct NewType(usize);\n\n    assert_eq!(\n        vec![NewType(1_usize); 10]\n            .into_boxed_slice()\n            .mem_size(SizeFlags::FOLLOW_REFS),\n        vec![1_usize; 10]\n            .into_boxed_slice()\n            .mem_size(SizeFlags::FOLLOW_REFS)\n    );\n}\n\n#[test]\nfn test_slice_copy_or_not() {\n    #[derive(Clone, MemSize)]\n    #[cfg_attr(feature = \"std\", derive(MemDbg))]\n    struct NewType(usize);\n\n    assert_eq!(\n        vec![NewType(1_usize); 10]\n            .into_boxed_slice()\n            .as_ref()\n            .mem_size(SizeFlags::FOLLOW_REFS),\n        vec![1_usize; 10]\n            .into_boxed_slice()\n            .as_ref()\n            .mem_size(SizeFlags::FOLLOW_REFS)\n    );\n}\n\n#[test]\nfn test_array_copy_or_not() {\n    #[derive(Clone, Copy, MemSize)]\n    #[cfg_attr(feature = \"std\", derive(MemDbg))]\n    struct NewType(usize);\n\n    assert_eq!(\n        [NewType(1_usize); 10]\n            .as_ref()\n            .mem_size(SizeFlags::FOLLOW_REFS),\n        [1_usize; 10].as_ref().mem_size(SizeFlags::FOLLOW_REFS)\n    );\n}\n\n#[test]\nfn test_empty_struct() {\n    #[derive(MemSize, Clone, Copy)]\n    #[copy_type]\n    struct Data {}\n    let v = Data {};\n    assert_eq!(v.mem_size(SizeFlags::default()), 0);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), 0);\n}\n\n#[test]\nfn test_struct() {\n    #[derive(MemSize)]\n    struct Data {\n        a: u64,\n        b: Vec\u003cusize\u003e,\n    }\n    let mut v = Data {\n        a: 10,\n        b: Vec::with_capacity(10),\n    };\n    v.b.push(1);\n    v.b.push(2);\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        8 + v.b.mem_size(SizeFlags::default())\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        8 + v.b.mem_size(SizeFlags::CAPACITY)\n    );\n}\n\n#[test]\nfn test_empty_tuple_struct() {\n    #[derive(MemSize)]\n    struct Data();\n    let v = Data();\n    assert_eq!(v.mem_size(SizeFlags::default()), 0);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), 0);\n}\n\n#[test]\nfn test_tuple_struct() {\n    #[derive(MemSize)]\n    struct Data(u64, Vec\u003cusize\u003e);\n    let mut v = Data(10, Vec::with_capacity(10));\n    v.1.push(1);\n    v.1.push(2);\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        8 + v.1.mem_size(SizeFlags::default())\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        8 + v.1.mem_size(SizeFlags::CAPACITY),\n    );\n}\n\n#[test]\nfn test_padding() {\n    assert_eq!((0_u8, 0_u64).mem_size(SizeFlags::default()), 16);\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    struct TuplePadded((u8, u64));\n    let v = TuplePadded((0, 0));\n    assert_eq!(v.mem_size(SizeFlags::default()), 16);\n\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    struct StructPadded(u8, u64);\n    let v = StructPadded(0, 0);\n    assert_eq!(v.mem_size(SizeFlags::default()), 16);\n\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    struct StructStructPadded(StructPadded);\n    let v = StructStructPadded(StructPadded(0, 0));\n    assert_eq!(v.mem_size(SizeFlags::default()), 16);\n}\n\n#[test]\nfn test_option() {\n    let v = Some(1_usize);\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        2 * core::mem::size_of::\u003cusize\u003e(),\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        v.mem_size(SizeFlags::default())\n    );\n    let v = Some(Some(1_usize));\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        2 * core::mem::size_of::\u003cusize\u003e(),\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        v.mem_size(SizeFlags::default())\n    );\n    let v = Some(Some(Some(1_usize)));\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        2 * core::mem::size_of::\u003cusize\u003e(),\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        v.mem_size(SizeFlags::default())\n    );\n}\n\n#[test]\nfn test_enum() {\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    #[repr(u8)]\n    enum Data {\n        A,\n        B(u64),\n        C(u64, Vec\u003cusize\u003e),\n    }\n\n    let enum_size = core::mem::size_of::\u003cData\u003e();\n\n    let v = Data::A;\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let v = Data::B(1000);\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let d = vec![1, 2, 3, 4, 5];\n    let len = d.len();\n    let capacity = d.capacity();\n    let v = Data::C(1000, d);\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        enum_size + core::mem::size_of::\u003cusize\u003e() * len\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        enum_size + core::mem::size_of::\u003cusize\u003e() * capacity\n    );\n}\n\n#[test]\n/// \u003chttps://github.com/rust-lang/rfcs/issues/1230\u003e\nfn test_exotic() {\n    // A reference cannot be null, so the compiler should use null as Option's\n    // None variant\n    let v: Option\u003c\u0026u8\u003e = None;\n    assert_eq!(core::mem::size_of::\u003cusize\u003e(), core::mem::size_of::\u003c\u0026u8\u003e());\n    assert_eq!(\n        core::mem::size_of::\u003cusize\u003e(),\n        core::mem::size_of::\u003cOption\u003c\u0026u8\u003e\u003e()\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        core::mem::size_of::\u003cusize\u003e()\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        core::mem::size_of::\u003cusize\u003e()\n    );\n\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    enum Data1 {\n        A,\n        B,\n    }\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    enum Data2 {\n        A,\n        B(Data1),\n    }\n\n    // nested enums can be flattened IFF they don't have a repr attribute\n    assert_eq!(core::mem::size_of::\u003cData1\u003e(), core::mem::size_of::\u003cData2\u003e(),);\n\n    let enum_size = core::mem::size_of::\u003cData1\u003e();\n    let v = Data1::A;\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let v = Data1::B;\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n\n    let enum_size = core::mem::size_of::\u003cData2\u003e();\n    let v = Data2::A;\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let v = Data2::B(Data1::A);\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let v = Data2::B(Data1::B);\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n}\n\n#[test]\nfn test_tuple() {\n    assert_eq!((8, 4).mem_size(SizeFlags::default()), 8);\n    assert_eq!((8, 4).mem_size(SizeFlags::CAPACITY), 8);\n}\n\n#[test]\nfn test_atomic() {\n    assert_eq!(AtomicU64::new(0).mem_size(SizeFlags::default()), 8);\n}\n\n#[test]\nfn test_unit() {\n    assert_eq!(().mem_size(SizeFlags::default()), 0);\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_phantom() {\n    struct Dummy();\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    #[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\n    struct Example\u003cA\u003e(PhantomData\u003cA\u003e);\n\n    Example::\u003cDummy\u003e(PhantomData)\n        .mem_dbg(DbgFlags::default())\n        .unwrap();\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_vec_strings() {\n    let data = vec![String::new(), String::new()];\n    data.mem_dbg(DbgFlags::default()).unwrap();\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_array_u8() {\n    let data = [0_u8; 10];\n    assert_eq!(data.mem_size(SizeFlags::default()), 10);\n    data.mem_dbg(DbgFlags::default()).unwrap();\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_array_empty_struct() {\n    #[derive(MemSize, MemDbg, Clone, Copy)]\n    struct Dummy;\n    let data = [Dummy; 10];\n    assert_eq!(data.mem_size(SizeFlags::default()), 0);\n    data.mem_dbg(DbgFlags::default()).unwrap();\n}\n\n#[test]\nfn test_slice_u8() {\n    let data = [0_u8; 10].as_slice();\n    assert_eq!((*data).mem_size(SizeFlags::default()), 10);\n    // Autodereferentiation\n    assert_eq!(data.mem_size(SizeFlags::default()), 10);\n    assert_eq!(\n        \u003c\u0026[u8] as MemSize\u003e::mem_size(\u0026data, SizeFlags::default()),\n        16\n    );\n    assert_eq!(\n        \u003c\u0026[u8] as MemSize\u003e::mem_size(\u0026data, SizeFlags::default() | SizeFlags::FOLLOW_REFS),\n        26\n    );\n}\n\n#[test]\nfn test_slice_empty_struct() {\n    #[derive(MemSize, MemDbg, Clone, Copy)]\n    struct Dummy;\n    let data = [Dummy; 10].as_slice();\n    assert_eq!((*data).mem_size(SizeFlags::default()), 0);\n    // Autodereferentiation\n    assert_eq!(data.mem_size(SizeFlags::default()), 0);\n    assert_eq!(\n        \u003c\u0026[Dummy] as MemSize\u003e::mem_size(\u0026data, SizeFlags::default()),\n        16\n    );\n    assert_eq!(\n        \u003c\u0026[Dummy] as MemSize\u003e::mem_size(\u0026data, SizeFlags::default() | SizeFlags::FOLLOW_REFS),\n        16\n    );\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_indirect_call() {\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    #[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\n    struct Dummy\u003cT\u003e(Vec\u003cT\u003e);\n\n    fn test\u003cT\u003e(data: Vec\u003cT\u003e)\n    where\n        // this is needed because the type system is not smart enough to infer it\n        Vec\u003cT\u003e: MemSize + MemDbgImpl,\n    {\n        let data = Dummy(data);\n        data.mem_dbg(DbgFlags::default()).unwrap();\n    }\n\n    test(vec![1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn test_vec_slice_i64() {\n    let mut data: Vec\u003ci64\u003e = vec![1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice = data.as_slice();\n    let size_of_non_mutable_slice = core::mem::size_of_val(non_mutable_slice);\n    let non_mutable_slice_shallow_size =\n        \u003c\u0026[i64] as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003c\u0026[i64] as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let mutable_slice = data.as_mut_slice();\n    let size_of_mutable_slice = core::mem::size_of_val(mutable_slice);\n\n    let mutable_slice_shallow_size =\n        \u003c\u0026mut [i64] as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003c\u0026mut [i64] as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n\n    assert_eq!(non_mutable_slice_shallow_size, size_of::\u003c\u0026[i64]\u003e());\n\n    assert_eq!(mutable_slice_shallow_size, size_of::\u003c\u0026mut [i64]\u003e());\n\n    assert_eq!(\n        non_mutable_slice_deep_size,\n        size_of::\u003c\u0026[i64]\u003e() + size_of_non_mutable_slice\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size,\n        size_of::\u003c\u0026mut [i64]\u003e() + size_of_mutable_slice\n    );\n}\n\n#[test]\nfn test_vec_slice_i32() {\n    let mut data: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice = data.as_slice();\n    let size_of_non_mutable_slice = core::mem::size_of_val(non_mutable_slice);\n    let non_mutable_slice_shallow_size =\n        \u003c\u0026[i32] as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003c\u0026[i32] as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let mutable_slice = data.as_mut_slice();\n    let size_of_mutable_slice = core::mem::size_of_val(mutable_slice);\n    let mutable_slice_shallow_size =\n        \u003c\u0026mut [i32] as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003c\u0026mut [i32] as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n\n    assert_eq!(non_mutable_slice_shallow_size, size_of::\u003c\u0026[i64]\u003e());\n\n    assert_eq!(mutable_slice_shallow_size, size_of::\u003c\u0026mut [i64]\u003e());\n\n    assert_eq!(\n        non_mutable_slice_deep_size,\n        size_of::\u003c\u0026[i64]\u003e() + size_of_non_mutable_slice\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size,\n        size_of::\u003c\u0026mut [i64]\u003e() + size_of_mutable_slice\n    );\n}\n\n#[test]\nfn test_array_slice_i64() {\n    let mut data: [i64; 5] = [1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice = data.as_slice();\n    let size_of_non_mutable_slice = core::mem::size_of_val(non_mutable_slice);\n    let non_mutable_slice_shallow_size =\n        \u003c\u0026[i64] as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003c\u0026[i64] as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let mutable_slice = data.as_mut_slice();\n    let size_of_mutable_slice = core::mem::size_of_val(mutable_slice);\n    let mutable_slice_shallow_size =\n        \u003c\u0026mut [i64] as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003c\u0026mut [i64] as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n\n    assert_eq!(\n        non_mutable_slice_deep_size,\n        core::mem::size_of::\u003c\u0026[i64]\u003e() + size_of_non_mutable_slice\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size,\n        core::mem::size_of::\u003c\u0026mut [i64]\u003e() + size_of_mutable_slice\n    );\n}\n\n#[test]\n#[should_panic]\nfn test_array_slice_i64_without_specifications() {\n    let mut data: [i64; 5] = [1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice_shallow_size = data.as_slice().mem_size(SizeFlags::default());\n    let non_mutable_slice_deep_size = data\n        .as_slice()\n        .mem_size(SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n    let mutable_slice_shallow_size = data\n        .as_mut_slice()\n        .mem_size(SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n    let mutable_slice_deep_size = data\n        .as_mut_slice()\n        .mem_size(SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n}\n\n#[test]\nfn test_array_slice_i32() {\n    let mut data: [i32; 5] = [1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice = data.as_slice();\n    let size_of_non_mutable_slice = core::mem::size_of_val(non_mutable_slice);\n    let non_mutable_slice_shallow_size =\n        \u003c\u0026[i32] as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003c\u0026[i32] as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let mutable_slice = data.as_mut_slice();\n    let size_of_mutable_slice = core::mem::size_of_val(mutable_slice);\n    let mutable_slice_shallow_size =\n        \u003c\u0026mut [i32] as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003c\u0026mut [i32] as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n\n    assert_eq!(\n        non_mutable_slice_deep_size,\n        core::mem::size_of::\u003c\u0026[i64]\u003e() + size_of_non_mutable_slice\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size,\n        core::mem::size_of::\u003c\u0026mut [i64]\u003e() + size_of_mutable_slice\n    );\n}\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\nstruct MutableSliceWrapper\u003c'a\u003e {\n    data: \u0026'a mut [i64],\n}\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\nstruct NonMutableSliceWrapper\u003c'a\u003e {\n    data: \u0026'a [i64],\n}\n\n#[test]\nfn test_compare_structs() {\n    let mut data: [i64; 5] = [1, 2, 3, 4, 5];\n    let mutable_slice = MutableSliceWrapper {\n        data: data.as_mut_slice(),\n    };\n    let mutable_slice_shallow_size =\n        \u003cMutableSliceWrapper as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003cMutableSliceWrapper as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let non_mutable_slice = NonMutableSliceWrapper {\n        data: data.as_slice(),\n    };\n    let non_mutable_slice_shallow_size =\n        \u003cNonMutableSliceWrapper as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003cNonMutableSliceWrapper as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n}\n\n/// Macro to generate test functions given a type T and the expected size.\nmacro_rules! test_size {\n    ($(($object:ty, $shallow_size:expr, $deep_size:expr)),*) =\u003e {\n        $(\n            paste::paste! {\n                #[test]\n                fn [\u003ctest_ $object:lower _size\u003e]() {\n                    // First, we check that the shallow size of the object is the expected one,\n                    // meaning that we are not following any reference\n                    let mut data: $object = Default::default();\n                    let shallow_object_size = \u003c$object as MemSize\u003e::mem_size(\u0026data, SizeFlags::default());\n                    assert_eq!(\n                        shallow_object_size,\n                        $shallow_size,\n                    );\n\n                    // We check that any pointer is always the size of a usize,\n                    // which is the size of a pointer on the current architecture\n                    let reference = \u0026data;\n                    let reference_size = \u003c\u0026'_ $object as MemSize\u003e::mem_size(\u0026reference, SizeFlags::default());\n\n                    assert_eq!(\n                        reference_size,\n                        core::mem::size_of::\u003cusize\u003e()\n                    );\n\n                    // Next, we check that the deep size of the object is the expected one,\n                    // meaning that we are following all references\n                    let deep_object_size = \u003c$object as MemSize\u003e::mem_size(\u0026data, SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n                    assert_eq!(\n                        deep_object_size,\n                        $deep_size\n                    );\n\n                    // We now  check that the deep size of the reference to this object is equal to the size of a pointer\n                    // plus the deep size of the object\n                    let deep_reference_size = \u003c\u0026'_ $object as MemSize\u003e::mem_size(\u0026reference, SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n                    assert_eq!(\n                        deep_reference_size,\n                        core::mem::size_of::\u003cusize\u003e() + deep_object_size\n                    );\n\n                    let mutable_reference = \u0026mut data;\n                    let mutable_reference_size = \u003c\u0026'_ mut $object as MemSize\u003e::mem_size(\u0026mutable_reference, SizeFlags::default());\n                    // We check that the mutable reference has the same size as the reference\n                    assert_eq!(\n                        mutable_reference_size,\n                        core::mem::size_of::\u003cusize\u003e(),\n                    );\n\n                    // We check that the deep size of the mutable reference is the same as the deep size of the reference\n                    // i.e. the size of a pointer plus the deep size of the object\n                    let deep_mutable_reference_size = \u003c\u0026'_ mut $object as MemSize\u003e::mem_size(\u0026mutable_reference, SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n                    assert_eq!(\n                        deep_mutable_reference_size,\n                        deep_reference_size,\n                    );\n                }\n            }\n        )*\n    };\n}\n\n#[derive(MemSize, Default)]\nenum TestEnum2 {\n    #[default]\n    A,\n    _B(u64),\n    _C(u64, Vec\u003cusize\u003e),\n}\n\n#[repr(u8)]\n#[derive(MemSize, Default)]\nenum TestEnumReprU8 {\n    #[default]\n    A,\n    _B(u64),\n    _C(u64, Vec\u003cusize\u003e),\n}\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\n#[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\nunion TestUnion {\n    a: u64,\n}\n\nimpl Default for TestUnion {\n    fn default() -\u003e Self {\n        TestUnion { a: 0 }\n    }\n}\n\ntest_size!(\n    (u8, 1, 1),\n    (u16, 2, 2),\n    (u32, 4, 4),\n    (u64, 8, 8),\n    (u128, 16, 16),\n    (i8, 1, 1),\n    (i16, 2, 2),\n    (i32, 4, 4),\n    (i64, 8, 8),\n    (i128, 16, 16),\n    (f32, 4, 4),\n    (f64, 8, 8),\n    (bool, 1, 1),\n    (char, 4, 4),\n    (TestEnum2, 32, 32),\n    (TestEnumReprU8, 40, 40),\n    (TestUnion, 8, 8)\n);\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\n#[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\nunion TestUnionDeep\u003c'a\u003e {\n    b: \u0026'a TestUnion,\n}\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\n#[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\nunion TestUnionDeepMut\u003c'a\u003e {\n    b: \u0026'a mut TestUnion,\n}\n\n#[test]\nfn test_single_field_union_follow_ref() {\n    let mut test_union = TestUnion::default();\n    let test_union_deep = TestUnionDeep { b: \u0026test_union };\n\n    // We check that the shallow size of the test union deep is the\n    // size of a reference (i.e. an usize).\n    assert_eq!(\n        \u003cTestUnionDeep as MemSize\u003e::mem_size(\u0026test_union_deep, SizeFlags::default()),\n        core::mem::size_of::\u003cusize\u003e(),\n    );\n\n    // We check that the deep size of the test union deep is the\n    // size of a reference plus the size of the test union.\n    assert_eq!(\n        \u003cTestUnionDeep as MemSize\u003e::mem_size(\u0026test_union_deep, SizeFlags::FOLLOW_REFS),\n        core::mem::size_of::\u003cusize\u003e()\n            + \u003cTestUnion as MemSize\u003e::mem_size(\u0026test_union, SizeFlags::default()),\n    );\n\n    let test_union_deep_mut = TestUnionDeepMut { b: \u0026mut test_union };\n\n    // We check that the shallow size of the test union mut is the\n    // size of a reference (i.e. an usize)\n    assert_eq!(\n        \u003cTestUnionDeepMut as MemSize\u003e::mem_size(\u0026test_union_deep_mut, SizeFlags::default()),\n        core::mem::size_of::\u003cusize\u003e(),\n    );\n\n    // We check that the deep size of the test union deep mut is the\n    // size of a reference plus the size of the test union.\n    assert_eq!(\n        \u003cTestUnionDeepMut as MemSize\u003e::mem_size(\u0026test_union_deep_mut, SizeFlags::FOLLOW_REFS),\n        core::mem::size_of::\u003cusize\u003e()\n            + \u003cTestUnion as MemSize\u003e::mem_size(\u0026test_union, SizeFlags::default()),\n    );\n}\n","traces":[{"line":669,"address":[],"length":0,"stats":{"Line":17}},{"line":672,"address":[],"length":0,"stats":{"Line":34}},{"line":673,"address":[],"length":0,"stats":{"Line":68}},{"line":674,"address":[],"length":0,"stats":{"Line":17}},{"line":681,"address":[],"length":0,"stats":{"Line":34}},{"line":682,"address":[],"length":0,"stats":{"Line":68}},{"line":684,"address":[],"length":0,"stats":{"Line":17}},{"line":691,"address":[],"length":0,"stats":{"Line":68}},{"line":692,"address":[],"length":0,"stats":{"Line":17}},{"line":699,"address":[],"length":0,"stats":{"Line":68}},{"line":700,"address":[],"length":0,"stats":{"Line":17}},{"line":702,"address":[],"length":0,"stats":{"Line":17}},{"line":705,"address":[],"length":0,"stats":{"Line":34}},{"line":706,"address":[],"length":0,"stats":{"Line":68}},{"line":708,"address":[],"length":0,"stats":{"Line":17}},{"line":715,"address":[],"length":0,"stats":{"Line":68}},{"line":716,"address":[],"length":0,"stats":{"Line":17}},{"line":750,"address":[],"length":0,"stats":{"Line":2}}],"covered":18,"coverable":18},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_mem_size_no_import.rs"],"content":"//! Test suite to verify whether derive works properly when MemSize is not imported outside of the derive.\n\n#[allow(dead_code)]\n#[cfg_attr(feature = \"derive\", derive(mem_dbg::MemSize))]\n#[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(mem_dbg::MemDbg))]\nstruct MyTestStruct(i32);\n\n#[test]\n#[cfg(feature = \"derive\")]\nfn test_mem_size_no_import() {\n    let my_test_struct = MyTestStruct(42);\n    let mem_size = \u003cMyTestStruct as mem_dbg::MemSize\u003e::mem_size(\n        \u0026my_test_struct,\n        mem_dbg::SizeFlags::default(),\n    );\n    assert_eq!(mem_size, 4);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_minimal_pathbuf.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2025 Inria\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n#![cfg(feature = \"std\")]\n#![cfg(feature = \"derive\")]\n\nuse mem_dbg::*;\nuse std::path::PathBuf;\n\n#[test]\nfn test_pathbuf_in_struct() {\n    #[derive(MemSize, MemDbg)]\n    struct Test {\n        path_buf: PathBuf,\n    }\n    \n    let s = Test { path_buf: PathBuf::from(\"/tmp/test\") };\n    let size = s.mem_size(SizeFlags::default());\n\n    assert_eq!(size, 24);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_minimal_unsafe_cell.rs"],"content":"#![cfg(feature = \"std\")]\n#![cfg(feature = \"derive\")]\n\nuse mem_dbg::*;\nuse core::cell::UnsafeCell;\n\n#[test]\nfn test_minimal_unsafecell_in_struct() {\n    #[derive(MemSize, MemDbg)]\n    struct Test {\n        field: UnsafeCell\u003ci32\u003e,\n    }\n    \n    let s = Test { field: UnsafeCell::new(42) };\n    let size = s.mem_size(SizeFlags::default());\n    assert_eq!(size, 4)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg-derive","src","lib.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n//! Derive procedural macros for the [`mem_dbg`](https://crates.io/crates/mem_dbg) crate.\n\nuse proc_macro::TokenStream;\nuse quote::{quote, ToTokens};\nuse syn::{\n    parse_macro_input, parse_quote, parse_quote_spanned, spanned::Spanned, Data, DeriveInput,\n};\n\n/**\n\nGenerate a `mem_dbg::MemSize` implementation for custom types.\n\nPresently we do not support unions.\n\nThe attribute `copy_type` can be used on [`Copy`] types that do not contain non-`'static` references\nto make `MemSize::mem_size` faster on arrays, vectors and slices. Note that specifying\n`copy_type` will add the bound that the type is `Copy + 'static`.\n\nSee `mem_dbg::CopyType` for more details.\n\n*/\n#[proc_macro_derive(MemSize, attributes(copy_type))]\npub fn mem_dbg_mem_size(input: TokenStream) -\u003e TokenStream {\n    let mut input = parse_macro_input!(input as DeriveInput);\n\n    let input_ident = input.ident;\n    input.generics.make_where_clause();\n    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n    let mut where_clause = where_clause.unwrap().clone(); // We just created it\n\n    let is_copy_type = input\n        .attrs\n        .iter()\n        .any(|x| x.meta.path().is_ident(\"copy_type\"));\n\n    // If copy_type, add the Copy + 'static bound\n    let copy_type: syn::Expr = if is_copy_type {\n        where_clause\n            .predicates\n            .push(parse_quote_spanned!(input_ident.span()=\u003e Self: Copy + 'static));\n        parse_quote!(mem_dbg::True)\n    } else {\n        parse_quote!(mem_dbg::False)\n    };\n\n    match input.data {\n        Data::Struct(s) =\u003e {\n            let mut fields_ident = vec![];\n            let mut fields_ty = vec![];\n\n            for (field_idx, field) in s.fields.iter().enumerate() {\n                fields_ident.push(\n                    field\n                        .ident\n                        .to_owned()\n                        .map(|t| t.to_token_stream())\n                        .unwrap_or(syn::Index::from(field_idx).to_token_stream()),\n                );\n                fields_ty.push(field.ty.to_token_stream());\n                let field_ty = \u0026field.ty;\n                // Add MemSize bound to all fields\n                where_clause\n                    .predicates\n                    .push(parse_quote_spanned!(field.span()=\u003e #field_ty: mem_dbg::MemSize));\n            }\n            quote! {\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::CopyType for #input_ident #ty_generics #where_clause\n                {\n                    type Copy = #copy_type;\n                }\n\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::MemSize for #input_ident #ty_generics #where_clause {\n                    fn mem_size(\u0026self, _memsize_flags: mem_dbg::SizeFlags) -\u003e usize {\n                        let mut bytes = core::mem::size_of::\u003cSelf\u003e();\n                        #(bytes += \u003c#fields_ty as mem_dbg::MemSize\u003e::mem_size(\u0026self.#fields_ident, _memsize_flags);)*\n                        #(bytes -= core::mem::size_of::\u003c#fields_ty\u003e();)*\n                        bytes\n                    }\n                }\n            }\n        }\n\n        Data::Enum(e) =\u003e {\n            let mut variants = Vec::new();\n            let mut variants_size = Vec::new();\n\n            for variant in e.variants {\n                let mut res = variant.ident.to_owned().to_token_stream();\n                let mut var_args_summations = vec![quote! {core::mem::size_of::\u003cSelf\u003e()}];\n                let mut var_args_subtractions = Vec::new();\n                match \u0026variant.fields {\n                    syn::Fields::Unit =\u003e {}\n                    syn::Fields::Named(fields) =\u003e {\n                        let mut args = Vec::new();\n                        for field in \u0026fields.named {\n                            let field_ty = \u0026field.ty;\n                            where_clause\n                                .predicates\n                                .push(parse_quote_spanned!(field.span() =\u003e #field_ty: mem_dbg::MemSize));\n                                let field_ident = \u0026field.ident;\n                                let field_ty = field.ty.to_token_stream();\n                                var_args_summations.push(quote! {\n                                    \u003c#field_ty as mem_dbg::MemSize\u003e::mem_size(#field_ident, _memsize_flags)\n                                });\n                                var_args_subtractions.push(quote! {\n                                    core::mem::size_of::\u003c#field_ty\u003e()\n                                });\n                                args.push(field_ident.to_token_stream());\n                            }\n                        // extend res with the args sourrounded by curly braces\n                        res.extend(quote! {\n                            { #(#args,)* }\n                        });\n                    }\n                    syn::Fields::Unnamed(fields) =\u003e {\n                        let mut args = Vec::new();\n\n                        for (field_idx, field) in fields.unnamed.iter().enumerate() {\n                            let ident = syn::Ident::new(\n                                \u0026format!(\"v{}\", field_idx),\n                                proc_macro2::Span::call_site(),\n                            )\n                            .to_token_stream();\n                            let field_ty = field.ty.to_token_stream();\n                            var_args_summations.push(quote! {\n                                \u003c#field_ty as mem_dbg::MemSize\u003e::mem_size(#ident, _memsize_flags)\n                            });\n                            var_args_subtractions.push(quote! {\n                                core::mem::size_of::\u003c#field_ty\u003e()\n                            });\n                            args.push(ident);\n\n                            where_clause\n                                .predicates\n                                .push(parse_quote_spanned!(field.span()=\u003e #field_ty: mem_dbg::MemSize));\n                        }\n                        // extend res with the args sourrounded by curly braces\n                        res.extend(quote! {\n                            ( #(#args,)* )\n                        });\n                    }\n                }\n                variants.push(res);\n                variants_size.push(quote! {\n                    {\n                        let mut bytes = 0;\n                        #(bytes += #var_args_summations;)*\n                        #(bytes -= #var_args_subtractions;)*\n                        bytes\n                    }\n                });\n            }\n\n            quote! {\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::CopyType for #input_ident #ty_generics #where_clause\n                {\n                    type Copy = #copy_type;\n                }\n\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::MemSize for #input_ident #ty_generics #where_clause {\n                    fn mem_size(\u0026self, _memsize_flags: mem_dbg::SizeFlags) -\u003e usize {\n                        match self {\n                            #(\n                               #input_ident::#variants =\u003e #variants_size,\n                            )*\n                        }\n                    }\n                }\n            }\n        }\n\n        Data::Union(u) =\u003e {\n            // We only support single-field unions completely or call to mem_size on unions\n            // without the FOLLOW_REFS flag, as we cannot know programmatically\n            // which field is initialized.\n\n            let fields = u.fields.named.iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n            match fields.len() {\n                0 =\u003e unreachable!(\"Empty unions are not supported by the Rust programming language.\"),\n                1 =\u003e {\n                    let field = fields[0];\n                    let field_ty = \u0026field.ty;\n                    let ident = field.ident.as_ref().unwrap();\n                    where_clause\n                        .predicates\n                        .push(parse_quote_spanned!(field.span() =\u003e #field_ty: mem_dbg::MemSize));\n                    quote! {\n                        #[automatically_derived]\n                        impl #impl_generics mem_dbg::CopyType for #input_ident #ty_generics #where_clause\n                        {\n                            type Copy = #copy_type;\n                        }\n\n                        #[automatically_derived]\n                        impl #impl_generics mem_dbg::MemSize for #input_ident #ty_generics #where_clause {\n                            fn mem_size(\u0026self, _memsize_flags: mem_dbg::SizeFlags) -\u003e usize {\n                                unsafe{\u003c#field_ty as mem_dbg::MemSize\u003e::mem_size(\u0026self.#ident, _memsize_flags)}\n                            }\n                        }\n                    }\n                }\n                number_of_fields =\u003e unimplemented!(\n                    \"mem_dbg::MemSize for unions with more than one field ({}) is not supported.\", number_of_fields\n                )\n            }\n        }\n    }.into()\n}\n\n/**\n\nGenerate a `mem_dbg::MemDbg` implementation for custom types.\n\nPresently we do not support unions.\n\n*/\n#[proc_macro_derive(MemDbg)]\npub fn mem_dbg_mem_dbg(input: TokenStream) -\u003e TokenStream {\n    let mut input = parse_macro_input!(input as DeriveInput);\n\n    let input_ident = input.ident;\n    input.generics.make_where_clause();\n    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n    let mut where_clause = where_clause.unwrap().clone(); // We just created it\n\n    match input.data {\n        Data::Struct(s) =\u003e {\n            let mut id_offset_pushes = vec![];\n            let mut match_code = vec![];\n\n            for (field_idx, field) in s.fields.iter().enumerate() {\n                // Use the field name for named structures, and the index\n                // for tuple structures\n                let field_ident = field\n                    .ident\n                    .to_owned()\n                    .map(|t| t.to_token_stream())\n                    .unwrap_or_else(|| syn::Index::from(field_idx).to_token_stream());\n\n                let field_ident_str = field\n                    .ident\n                    .to_owned()\n                    .map(|t| t.to_string().to_token_stream())\n                    .unwrap_or_else(|| field_idx.to_string().to_token_stream());\n\n                let field_ty = \u0026field.ty;\n                where_clause\n                    .predicates\n                    .push(parse_quote_spanned!(field.span() =\u003e #field_ty: mem_dbg::MemDbgImpl));\n\n                // We push the field index and its offset\n                id_offset_pushes.push(quote!{\n                    id_sizes.push((#field_idx, core::mem::offset_of!(#input_ident #ty_generics, #field_ident)));\n                });\n                // This is the arm of the match statement that invokes\n                // _mem_dbg_depth_on on the field.\n                match_code.push(quote!{\n                    #field_idx =\u003e \u003c#field_ty as mem_dbg::MemDbgImpl\u003e::_mem_dbg_depth_on(\u0026self.#field_ident, _memdbg_writer, _memdbg_total_size, _memdbg_max_depth, _memdbg_prefix, Some(#field_ident_str), i == n - 1, padded_size, _memdbg_flags)?,\n                });\n            }\n\n            quote! {\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::MemDbgImpl for #input_ident #ty_generics #where_clause {\n                    #[inline(always)]\n                    fn _mem_dbg_rec_on(\n                        \u0026self,\n                        _memdbg_writer: \u0026mut impl core::fmt::Write,\n                        _memdbg_total_size: usize,\n                        _memdbg_max_depth: usize,\n                        _memdbg_prefix: \u0026mut String,\n                        _memdbg_is_last: bool,\n                        _memdbg_flags: mem_dbg::DbgFlags,\n                    ) -\u003e core::fmt::Result {\n                        let mut id_sizes: Vec\u003c(usize, usize)\u003e = vec![];\n                        #(#id_offset_pushes)*\n                        let n = id_sizes.len();\n                        id_sizes.push((n, core::mem::size_of::\u003cSelf\u003e()));\n                        // Sort by offset\n                        id_sizes.sort_by_key(|x| x.1);\n                        // Compute padded sizes\n                        for i in 0..n {\n                            id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;\n                        };\n                        // Put the candle back unless the user requested otherwise\n                        if ! _memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {\n                            id_sizes.sort_by_key(|x| x.0);\n                        }\n\n                        for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n) {\n                            match field_idx {\n                                #(#match_code)*\n                                _ =\u003e unreachable!(),\n                            }\n                        }\n                        Ok(())\n                    }\n                }\n            }\n        }\n\n        Data::Enum(e) =\u003e {\n            let mut variants = Vec::new();\n            let mut variants_code = Vec::new();\n\n            for variant in \u0026e.variants {\n                let variant_ident = \u0026variant.ident;\n                let mut res = variant.ident.to_owned().to_token_stream();\n                // Depending on the presence of the feature offset_of_enum, this\n                // will contains field indices and offset_of or field indices\n                // and size_of; in the latter case, we will assume size_of to be\n                // the padded size, resulting in no padding.\n                let mut id_offset_pushes = vec![];\n                let mut match_code = vec![];\n                let mut arrow = '';\n                match \u0026variant.fields {\n                    syn::Fields::Unit =\u003e {},\n                    syn::Fields::Named(fields) =\u003e {\n                        let mut args = proc_macro2::TokenStream::new();\n                        if !fields.named.is_empty() {\n                            arrow = '';\n                        }\n                        for (field_idx, field) in fields.named.iter().enumerate() {\n                            let field_ty = \u0026field.ty;\n                            let field_ident = field.ident.as_ref().unwrap();\n                            let field_ident_str = format!(\"{}\", field_ident);\n\n                            #[cfg(feature = \"offset_of_enum\")]\n                            id_offset_pushes.push(quote!{\n                                // We push the offset of the field, which will\n                                // be used to compute the padded size.\n                                id_sizes.push((#field_idx, core::mem::offset_of!(#input_ident #ty_generics, #variant_ident . #field_ident)));\n                            });\n                            #[cfg(not(feature = \"offset_of_enum\"))]\n                            id_offset_pushes.push(quote!{\n                                id_sizes.push((#field_idx, core::mem::offset_of!(#input_ident #ty_generics, #variant_ident . #field_ident)));\n                                // We push the size of the field, which will be\n                                // used as a surrogate of the padded size.\n                                id_sizes.push((#field_idx, std::mem::size_of_val(#field_ident)));\n                            });\n\n                            // This is the arm of the match statement that\n                            // invokes _mem_dbg_depth_on on the field.\n                            match_code.push(quote! {\n                                #field_idx =\u003e \u003c#field_ty as mem_dbg::MemDbgImpl\u003e::_mem_dbg_depth_on(#field_ident, _memdbg_writer, _memdbg_total_size, _memdbg_max_depth, _memdbg_prefix, Some(#field_ident_str), i == n - 1, padded_size, _memdbg_flags)?,\n                            });\n                            args.extend([field_ident.to_token_stream()]);\n                            args.extend([quote! {,}]);\n\n                            let field_ty = \u0026field.ty;\n                            where_clause\n                                .predicates\n                                .push(parse_quote_spanned!(field.span()=\u003e #field_ty: mem_dbg::MemDbgImpl));\n                        }\n                        // extend res with the args sourrounded by curly braces\n                        res.extend(quote! {\n                            // TODO: sanitize somehow the names or it'll be\n                            // havoc.\n                            { #args }\n                        });\n                    }\n                    syn::Fields::Unnamed(fields) =\u003e {\n                        let mut args = proc_macro2::TokenStream::new();\n                        if !fields.unnamed.is_empty() {\n                            arrow = '';\n                        }\n                        for (field_idx, field) in fields.unnamed.iter().enumerate() {\n                            let field_ident = syn::Ident::new(\n                                \u0026format!(\"v{}\", field_idx),\n                                proc_macro2::Span::call_site(),\n                            )\n                            .to_token_stream();\n                            let field_ty = \u0026field.ty;\n                            let field_ident_str = format!(\"{}\", field_idx);\n                            let _field_tuple_idx = syn::Index::from(field_idx);\n\n                            #[cfg(feature = \"offset_of_enum\")]\n                            id_offset_pushes.push(quote!{\n                                // We push the offset of the field, which will\n                                // be used to compute the padded size.\n                                id_sizes.push((#field_idx, core::mem::offset_of!(#input_ident #ty_generics, #variant_ident . #_field_tuple_idx)));\n                            });\n\n                            #[cfg(not(feature = \"offset_of_enum\"))]\n                            id_offset_pushes.push(quote!{\n                                // We push the size of the field, which will be\n                                // used as a surrogate of the padded size.\n                                id_sizes.push((#field_idx, std::mem::size_of_val(#field_ident)));\n                            });\n\n                            // This is the arm of the match statement that\n                            // invokes _mem_dbg_depth_on on the field.\n                            match_code.push(quote! {\n                                #field_idx =\u003e \u003c#field_ty as mem_dbg::MemDbgImpl\u003e::_mem_dbg_depth_on(#field_ident, _memdbg_writer, _memdbg_total_size, _memdbg_max_depth, _memdbg_prefix, Some(#field_ident_str), i == n - 1, padded_size, _memdbg_flags)?,\n                            });\n\n                            args.extend([field_ident]);\n                            args.extend([quote! {,}]);\n\n                            let field_ty = \u0026field.ty;\n                            where_clause\n                                .predicates\n                                .push(parse_quote_spanned!(field.span()=\u003e #field_ty: mem_dbg::MemDbgImpl));\n                        }\n                        // extend res with the args sourrounded by curly braces\n                        res.extend(quote! {\n                            ( #args )\n                        });\n                    }\n                }\n                variants.push(res);\n                let variant_name = format!(\"Variant: {}\\n\", variant.ident);\n                variants_code.push(quote!{{\n                    _memdbg_writer.write_char(#arrow)?;\n                    _memdbg_writer.write_char('')?;\n                    _memdbg_writer.write_str(#variant_name)?;\n                }});\n\n                // There's some abundant code duplication here, but we need to\n                // keep the #[cfg] attributes outside of the quote! macro.\n\n                #[cfg(feature = \"offset_of_enum\")]\n                variants_code.push(quote!{{\n                    let mut id_sizes: Vec\u003c(usize, usize)\u003e = vec![];\n                    #(#id_offset_pushes)*\n                    let n = id_sizes.len();\n\n                    // We use the offset_of information to build the real\n                    // space occupied by a field.\n                    id_sizes.push((n, core::mem::size_of::\u003cSelf\u003e()));\n                    // Sort by offset\n                    id_sizes.sort_by_key(|x| x.1);\n                    // Compute padded sizes\n                    for i in 0..n {\n                        id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;\n                    };\n                    // Put the candle back unless the user requested otherwise\n                    if ! _memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {\n                        id_sizes.sort_by_key(|x| x.0);\n                    }\n\n                    for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n) {\n                        match field_idx {\n                            #(#match_code)*\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }});\n\n                #[cfg(not(feature = \"offset_of_enum\"))]\n                variants_code.push(quote!{{\n                    let mut id_sizes: Vec\u003c(usize, usize)\u003e = vec![];\n                    #(#id_offset_pushes)*\n                    let n = id_sizes.len();\n\n                    // Lacking offset_of for enums, id_sizes contains the\n                    // size_of of each field which we use as a surrogate of\n                    // the padded size.\n                    assert!(!_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT), \"DbgFlags::RUST_LAYOUT for enums requires the offset_of_enum feature\");\n\n                    for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n) {\n                        match field_idx {\n                            #(#match_code)*\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }});\n            }\n\n            quote! {\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::MemDbgImpl  for #input_ident #ty_generics #where_clause {\n                    #[inline(always)]\n                    fn _mem_dbg_rec_on(\n                        \u0026self,\n                        _memdbg_writer: \u0026mut impl core::fmt::Write,\n                        _memdbg_total_size: usize,\n                        _memdbg_max_depth: usize,\n                        _memdbg_prefix: \u0026mut String,\n                        _memdbg_is_last: bool,\n                        _memdbg_flags: mem_dbg::DbgFlags,\n                    ) -\u003e core::fmt::Result {\n                        let mut _memdbg_digits_number = mem_dbg::n_of_digits(_memdbg_total_size);\n                        if _memdbg_flags.contains(mem_dbg::DbgFlags::SEPARATOR) {\n                            _memdbg_digits_number += _memdbg_digits_number / 3;\n                        }\n                        if _memdbg_flags.contains(mem_dbg::DbgFlags::HUMANIZE) {\n                            _memdbg_digits_number = 6;\n                        }\n\n                        if _memdbg_flags.contains(mem_dbg::DbgFlags::PERCENTAGE) {\n                            _memdbg_digits_number += 8;\n                        }\n\n                        for _ in 0.._memdbg_digits_number + 3 {\n                            _memdbg_writer.write_char(' ')?;\n                        }\n                        if !_memdbg_prefix.is_empty() {\n                            _memdbg_writer.write_str(\u0026_memdbg_prefix[2..])?;\n                        }\n                        match self {\n                            #(\n                               #input_ident::#variants =\u003e #variants_code,\n                            )*\n                        }\n                        Ok(())\n                   }\n                }\n            }\n        }\n\n        Data::Union(u) =\u003e {\n            // We only support single-field unions for the MemDbg.\n\n            let fields = u.fields.named.iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n            match fields.len() {\n                0 =\u003e unreachable!(\"Empty unions are not supported by the Rust programming language.\"),\n                1 =\u003e {\n                    let field = fields[0];\n                    let field_ty = \u0026field.ty;\n                    let ident = field.ident.as_ref().unwrap();\n                    where_clause\n                        .predicates\n                        .push(parse_quote_spanned!(field.span() =\u003e #field_ty: mem_dbg::MemDbgImpl));\n                    quote! {\n                        #[automatically_derived]\n                        impl #impl_generics mem_dbg::MemDbgImpl for #input_ident #ty_generics #where_clause {\n                            #[inline(always)]\n                            fn _mem_dbg_rec_on(\n                                \u0026self,\n                                _memdbg_writer: \u0026mut impl core::fmt::Write,\n                                _memdbg_total_size: usize,\n                                _memdbg_max_depth: usize,\n                                _memdbg_prefix: \u0026mut String,\n                                _memdbg_is_last: bool,\n                                _memdbg_flags: mem_dbg::DbgFlags,\n                            ) -\u003e core::fmt::Result {\n                                unsafe{\u003c#field_ty as mem_dbg::MemDbgImpl\u003e::_mem_dbg_depth_on(\u0026self.#ident, _memdbg_writer, _memdbg_total_size, _memdbg_max_depth, _memdbg_prefix, None, _memdbg_is_last, core::mem::size_of::\u003c#field_ty\u003e(), _memdbg_flags)}\n                            }\n                        }\n                    }\n                }\n                _ =\u003e unimplemented!(\n                    \"mem_dbg::MemDbg for unions with more than one field is not supported.\"\n                )\n            }\n        }\n    }.into()\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":183}]};
        var previousData = {"files":[{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","examples","bench_hash_map.rs"],"content":"use cap::Cap;\nuse deepsize::*;\nuse get_size::*;\nuse mem_dbg::*;\nuse std::alloc;\nuse std::collections::HashMap;\nuse std::time::Instant;\n\n#[global_allocator]\nstatic ALLOCATOR: Cap\u003calloc::System\u003e = Cap::new(alloc::System, usize::MAX);\n\nfn main() {\n    const N: usize = 100_000_000;\n    let mut m = HashMap::with_capacity(N);\n    for i in 0..N {\n        m.insert(i, i);\n    }\n\n    println!(\"Allocated:    {}\", ALLOCATOR.allocated());\n\n    let start = Instant::now();\n    let size = m.get_size();\n    println!(\"get_size:     {} {:?} ns\", size, start.elapsed().as_nanos());\n\n    let start = Instant::now();\n    let size = m.deep_size_of();\n    println!(\"deep_size_of: {} {:?} ns\", size, start.elapsed().as_nanos());\n\n    // Commented out as `size-of` crate is currently broken.\n    // let start = Instant::now();\n    // let size = m.size_of().total_bytes();\n    // println!(\"size_of:      {} {:?} ns\", size, start.elapsed().as_nanos());\n\n    let start = Instant::now();\n    let size = m.mem_size(SizeFlags::default());\n    println!(\"mem_size:     {} {:?} ns\", size, start.elapsed().as_nanos());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","examples","example.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n#![cfg_attr(feature = \"offset_of_enum\", feature(offset_of_enum))]\n#![allow(dead_code)]\n\nuse mem_dbg::*;\n\n#[derive(Clone, Copy, MemSize, MemDbg)]\n#[copy_type]\nenum TestEnum {\n    Unit,\n    Unit2(),\n    Unit3 {},\n    Unnamed(usize, u8),\n    Named { first: usize, second: u8 },\n}\n\n#[derive(Clone, Copy, MemSize, MemDbg)]\nstruct TestMarker;\n\n#[derive(Clone, Copy, MemSize, MemDbg)]\nstruct TestTuple(usize, u8);\n\n#[derive(MemSize, MemDbg)]\n#[cfg(feature = \"std\")]\nstruct Struct\u003cA, B\u003e {\n    a: A,\n    b: B,\n    test: isize,\n    h: std::collections::HashSet\u003cusize\u003e,\n}\n\n#[derive(MemSize, MemDbg)]\nstruct Data\u003cA\u003e {\n    a: A,\n    b: Vec\u003ci32\u003e,\n    c: (u8, String),\n}\n\n#[cfg(feature = \"std\")]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut b = Vec::with_capacity(100);\n    b.extend(0..10);\n    let mut h = std::collections::HashSet::with_capacity(100);\n    h.extend(0..10);\n\n    let s = Struct {\n        a: TestEnum::Unnamed(0, 16),\n        b: Data {\n            a: vec![0x42_u8; 700],\n            b: b.clone(),\n            c: (1, \"foo\".to_owned()),\n        },\n        test: -0xbadf00d,\n        h: h.clone(),\n    };\n\n    // print the size in bytes of the value\n    println!(\"size:     {}\", s.mem_size(SizeFlags::default()));\n    println!(\"capacity: {}\", s.mem_size(SizeFlags::CAPACITY));\n\n    println!();\n\n    println!(\"DbgFlags::default():\");\n    println!();\n    s.mem_dbg(DbgFlags::default())?;\n\n    println!();\n\n    println!(\"DbgFlags::default() | DbgFlags::CAPACITY:\");\n    println!();\n    s.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY)?;\n\n    println!();\n\n    println!(\"DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE:\");\n    println!();\n    s.mem_dbg(DbgFlags::default() | DbgFlags::HUMANIZE)?;\n\n    println!();\n\n    println!(\"DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE:\");\n    println!();\n    s.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE)?;\n\n    println!();\n\n    let s = Struct {\n        a: TestEnum::Named {\n            first: 0,\n            second: 1,\n        },\n        b: Data {\n            a: vec![0x42_u8; 700],\n            b,\n            c: (1, \"foo\".to_owned()),\n        },\n        test: -0xbadf00d,\n        h,\n    };\n\n    println!(\"DbgFlags::empty():\");\n    println!();\n    s.mem_dbg(DbgFlags::empty())?;\n\n    #[cfg(feature = \"offset_of_enum\")]\n    {\n        println!();\n        println!(\"DbgFlags::HUMANIZE | DbgFlags::RUST_LAYOUT:\");\n        println!();\n        s.mem_dbg(DbgFlags::HUMANIZE | DbgFlags::RUST_LAYOUT)?;\n    }\n    let s = Struct {\n        a: 0_u8,\n        b: 0_u8,\n        test: 1,\n        h: std::collections::HashSet::new(),\n    };\n\n    println!();\n\n    println!(\"DbgFlags::empty()\");\n    println!();\n    s.mem_dbg(DbgFlags::empty())?;\n\n    println!();\n\n    println!(\"DbgFlags::RUST_LAYOUT\");\n    println!();\n    s.mem_dbg(DbgFlags::RUST_LAYOUT)?;\n\n    Ok(())\n}\n\n#[cfg(not(feature = \"std\"))]\nfn main() {\n    println!(\"This example requires the 'std' feature.\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","examples","readme.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n#![cfg_attr(feature = \"offset_of_enum\", feature(offset_of_enum))]\n#![allow(dead_code)]\n\n#[cfg(feature = \"std\")]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    use mem_dbg::*;\n\n    #[derive(MemSize, MemDbg)]\n    struct Struct\u003cA, B\u003e {\n        a: A,\n        b: B,\n        test: isize,\n    }\n\n    #[derive(MemSize, MemDbg)]\n    struct Data\u003cA\u003e {\n        a: A,\n        b: Vec\u003ci32\u003e,\n        c: (u8, String),\n    }\n\n    #[derive(MemSize, MemDbg)]\n    enum TestEnum {\n        Unit,\n        Unit2(),\n        Unit3 {},\n        Unnamed(usize, usize),\n        Named { first: usize, second: u8 },\n    }\n\n    let b = Vec::with_capacity(100);\n\n    let s = Struct {\n        a: TestEnum::Unnamed(0, 16),\n        b: Data {\n            a: vec![0x42_u8; 700],\n            b,\n            c: (1, \"foo\".to_owned()),\n        },\n        test: -0xbadf00d,\n    };\n\n    println!(\"size:     {}\", s.mem_size(SizeFlags::default()));\n    println!(\"capacity: {}\", s.mem_size(SizeFlags::CAPACITY));\n    println!();\n\n    s.mem_dbg(DbgFlags::empty())?;\n\n    println!();\n\n    println!(\"size:     {}\", s.mem_size(SizeFlags::default()));\n    println!(\"capacity: {}\", s.mem_size(SizeFlags::CAPACITY));\n    println!();\n\n    s.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE)?;\n\n    #[cfg(feature = \"offset_of_enum\")]\n    {\n        println!();\n\n        println!(\"size:     {}\", s.mem_size(SizeFlags::default()));\n        println!(\"capacity: {}\", s.mem_size(SizeFlags::CAPACITY));\n        println!();\n\n        s.mem_dbg(DbgFlags::empty() | DbgFlags::RUST_LAYOUT)?;\n    }\n    Ok(())\n}\n\n#[cfg(not(feature = \"std\"))]\nfn main() {\n    println!(\"This example requires the 'std' feature.\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","src","impl_mem_dbg.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\nuse core::marker::PhantomPinned;\nuse core::num::*;\nuse core::{marker::PhantomData, sync::atomic::*};\n\nuse crate::{CopyType, DbgFlags, MemDbgImpl, impl_mem_size::MemSizeHelper};\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::{boxed::Box, string::String, vec, vec::Vec};\n\n/// Implements [`MemDbg`] using the default implementation of [`MemDbgImpl`].\nmacro_rules! impl_mem_dbg {\n     ($($ty:ty),*) =\u003e {$(\n impl MemDbgImpl for $ty {}\n     )*};\n }\n\nimpl_mem_dbg! {\n    (), bool, char, f32, f64,\n    u8, u16, u32, u64, u128, usize,\n    i8, i16, i32, i64, i128, isize,\n    AtomicBool,\n    AtomicI8, AtomicI16, AtomicI32, AtomicI64, AtomicIsize,\n    AtomicU8, AtomicU16, AtomicU32, AtomicU64, AtomicUsize,\n    NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize,\n    NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize,\n    PhantomPinned, str, String\n}\n\nimpl\u003cT: ?Sized\u003e MemDbgImpl for PhantomData\u003cT\u003e {}\n\n// References: we recurse only if FOLLOW_REFS is set\nimpl\u003cT: ?Sized + MemDbgImpl\u003e MemDbgImpl for \u0026'_ T {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            (**self)._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\nimpl\u003cT: ?Sized + MemDbgImpl\u003e MemDbgImpl for \u0026'_ mut T {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            (**self)._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n// Option\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for Option\u003cT\u003e {}\n\n// Box\n\nimpl\u003cT: ?Sized + MemDbgImpl\u003e MemDbgImpl for Box\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.as_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::sync::Arc;\n#[cfg(feature = \"std\")]\nuse std::sync::Arc;\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for Arc\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.as_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n// Slices\n\nimpl\u003cT: CopyType + MemDbgImpl\u003e MemDbgImpl for [T] where [T]: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e {}\n\n// Arrays\n\nimpl\u003cT: CopyType + MemDbgImpl, const N: usize\u003e MemDbgImpl for [T; N] where\n    [T; N]: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\n{\n}\n\n// Vectors\n\nimpl\u003cT: CopyType + MemDbgImpl\u003e MemDbgImpl for Vec\u003cT\u003e where\n    Vec\u003cT\u003e: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\n{\n}\n\n// Tuples\n\nmacro_rules! impl_tuples_muncher {\n    () =\u003e {};\n\n    (($idx:tt =\u003e $ty:ident), $(($i:tt =\u003e $t:ident),)*) =\u003e {\n        // Pass to list reversal\n        impl_tuples_muncher!([($idx =\u003e $ty);] $(($i =\u003e $t),)*);\n        // Recurse on tail\n        impl_tuples_muncher!($(($i =\u003e $t),)*);\n    };\n\n    // List reversal\n    ([$(($accIdx: tt =\u003e $accTyp: ident);)+]  ($idx:tt =\u003e $typ:ident), $( ($nidx:tt =\u003e $ntyp:ident), )*) =\u003e {\n        impl_tuples_muncher!([($idx =\u003e $typ); $(($accIdx =\u003e $accTyp); )*] $( ($nidx =\u003e $ntyp), ) *);\n    };\n\n    // Implement on reversed list, building the tuple type as we cannot expand\n    // recursively\n    ([($idx:tt =\u003e $ty:ident); $( ($nidx:tt =\u003e $nty:ident); )*]) =\u003e {\n        impl_tuples_muncher!([($idx =\u003e $ty); $(($nidx =\u003e $nty);)* ], ($ty, $($nty,)*));\n    };\n\n    // Implement on reversed list and tuple type\n    ([($idx:tt =\u003e $ty:ident); $( ($nidx:tt =\u003e $nty:ident); )*], $tty:ty) =\u003e {\n        impl\u003c$ty: crate::MemSize + MemDbgImpl, $($nty: crate::MemSize + MemDbgImpl,)*\u003e MemDbgImpl for ($ty, $($nty,)*)  {\n            fn _mem_dbg_rec_on(\n                \u0026self,\n                writer: \u0026mut impl core::fmt::Write,\n                total_size: usize,\n                max_depth: usize,\n                prefix: \u0026mut String,\n                _is_last: bool,\n                flags: DbgFlags,\n            ) -\u003e core::fmt::Result {\n                // Compute size of tuple minus one for last-field check.\n                let mut _max_idx = $idx;\n                $(_max_idx = _max_idx.max($nidx);)*\n\n                let mut id_sizes: Vec\u003c(usize, usize)\u003e = vec![];\n                let n;\n\n                {\n                    // We use the offset_of information to build the real\n                    // space occupied by a field.\n                    id_sizes.push(($idx, core::mem::offset_of!($tty, $idx)));\n                    $(id_sizes.push(($nidx, core::mem::offset_of!($tty, $nidx)));)*\n                    n = id_sizes.len();\n                    id_sizes.push((n, core::mem::size_of::\u003cSelf\u003e()));\n                    // Sort by offset\n                    id_sizes.sort_by_key(|x| x.1);\n                    // Compute actual sizes\n                    for i in 0..n {\n                        id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;\n                    };\n                    // Put the candle back\n                    id_sizes.sort_by_key(|x| x.0);\n                }\n\n                self.$idx._mem_dbg_depth_on(writer, total_size, max_depth, prefix, Some(stringify!($idx)), $idx == _max_idx, id_sizes[$idx].1, flags)?;\n                $(\n                    self.$nidx._mem_dbg_depth_on(writer, total_size, max_depth, prefix, Some(stringify!($nidx)), $nidx == _max_idx, id_sizes[$nidx].1, flags)?;\n                )*\n                Ok(())\n            }\n        }\n    };\n}\n\nimpl_tuples_muncher!(\n    (9 =\u003e T9),\n    (8 =\u003e T8),\n    (7 =\u003e T7),\n    (6 =\u003e T6),\n    (5 =\u003e T5),\n    (4 =\u003e T4),\n    (3 =\u003e T3),\n    (2 =\u003e T2),\n    (1 =\u003e T1),\n    (0 =\u003e T0),\n);\n\n// Function pointers cannot recurse\n\nimpl\u003cR\u003e MemDbgImpl for fn() -\u003e R {}\nimpl\u003cA, R\u003e MemDbgImpl for fn(A) -\u003e R {}\nimpl\u003cA, B, R\u003e MemDbgImpl for fn(A, B) -\u003e R {}\nimpl\u003cA, B, C, R\u003e MemDbgImpl for fn(A, B, C) -\u003e R {}\nimpl\u003cA, B, C, D, R\u003e MemDbgImpl for fn(A, B, C, D) -\u003e R {}\n\n// Hash-based containers from the standard library\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType\u003e MemDbgImpl for std::collections::HashSet\u003cK\u003e where\n    std::collections::HashSet\u003cK\u003e: MemSizeHelper\u003c\u003cK as CopyType\u003e::Copy\u003e\n{\n}\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType, V: CopyType\u003e MemDbgImpl for std::collections::HashMap\u003cK, V\u003e where\n    std::collections::HashMap\u003cK, V\u003e:\n        crate::impl_mem_size::MemSizeHelper2\u003c\u003cK as CopyType\u003e::Copy, \u003cV as CopyType\u003e::Copy\u003e\n{\n}\n\n// Hash stuff\n\n#[cfg(feature = \"mmap-rs\")]\nimpl_mem_dbg!(mmap_rs::Mmap, mmap_rs::MmapMut);\n\nimpl\u003cH\u003e MemDbgImpl for core::hash::BuildHasherDefault\u003cH\u003e {\n    // it's a phantom data so no recursion\n}\n\n#[cfg(feature = \"std\")]\nimpl MemDbgImpl for std::collections::hash_map::RandomState {\n    // it's two u64s, but they are private so can't recurse\n}\n\n// alloc\n\n#[cfg(feature = \"std\")]\nimpl MemDbgImpl for core::alloc::Layout {\n    // Layout is size + align, but align is unstable so we can't recurse\n    // on that, nor implement memdbg or memsize for that :)\n}\n\n// Ranges\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::Range\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.start\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)?;\n        self.end\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::RangeFrom\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.start\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::RangeInclusive\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.start()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)?;\n        self.end()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::RangeTo\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.end\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cIdx: MemDbgImpl\u003e MemDbgImpl for core::ops::RangeToInclusive\u003cIdx\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.end\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e MemDbgImpl for core::ptr::NonNull\u003cT\u003e {\n    // no recursion because we don't follow pointers\n}\n\n// Rand crate\n\n#[cfg(feature = \"rand\")]\nimpl_mem_dbg!(\n    rand::rngs::SmallRng,\n    rand::rngs::StdRng,\n    rand::rngs::ThreadRng\n);\n\n// Cells\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for core::cell::RefCell\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.borrow()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for core::cell::Cell\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        unsafe {\n            (*self.as_ptr())._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        }\n    }\n}\n\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for core::cell::UnsafeCell\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        unsafe {\n            (*self.get())._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        }\n    }\n}\n\n// Mutexes\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::Mutex\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.lock()\n            .unwrap()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::RwLock\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.read()\n            .unwrap()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::cell::OnceCell\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.get()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::MutexGuard\u003c'_, T\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        use core::ops::Deref;\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            self.deref()\n                ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::RwLockReadGuard\u003c'_, T\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        use core::ops::Deref;\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            self.deref()\n                ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::sync::RwLockWriteGuard\u003c'_, T\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        use core::ops::Deref;\n        if flags.contains(DbgFlags::FOLLOW_REFS) {\n            self.deref()\n                ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n// Os stuff\n\n#[cfg(feature = \"std\")]\nimpl_mem_dbg!(\n    std::path::Path,\n    std::path::PathBuf,\n    std::ffi::OsStr,\n    std::ffi::OsString,\n    std::fs::File,\n    std::fs::OpenOptions,\n    std::fs::Metadata,\n    std::fs::FileTimes,\n    std::fs::FileType,\n    std::fs::Permissions\n);\n\n// I/O\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl + std::io::Read\u003e MemDbgImpl for std::io::BufReader\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.get_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl + std::io::Write\u003e MemDbgImpl for std::io::BufWriter\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.get_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemDbgImpl\u003e MemDbgImpl for std::io::Cursor\u003cT\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self.get_ref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n// maligned crate\n\n#[cfg(feature = \"maligned\")]\nimpl_mem_dbg!(\n    maligned::A2,\n    maligned::A4,\n    maligned::A8,\n    maligned::A16,\n    maligned::A32,\n    maligned::A64,\n    maligned::A128,\n    maligned::A256,\n    maligned::A512\n);\n\n#[cfg(feature = \"maligned\")]\nimpl\u003cA: maligned::Alignment, T: MemDbgImpl\u003e MemDbgImpl for maligned::Aligned\u003cA, T\u003e {\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        is_last: bool,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        use core::ops::Deref;\n        self.deref()\n            ._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)\n    }\n}\n\n// half crate\n\n#[cfg(feature = \"half\")]\nimpl_mem_dbg!(half::f16, half::bf16);\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":8}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":28}},{"line":103,"address":[],"length":0,"stats":{"Line":5}},{"line":112,"address":[],"length":0,"stats":{"Line":5}},{"line":113,"address":[],"length":0,"stats":{"Line":35}},{"line":161,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":12}},{"line":163,"address":[],"length":0,"stats":{"Line":12}},{"line":164,"address":[],"length":0,"stats":{"Line":12}},{"line":165,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":12}},{"line":168,"address":[],"length":0,"stats":{"Line":12}},{"line":169,"address":[],"length":0,"stats":{"Line":12}},{"line":171,"address":[],"length":0,"stats":{"Line":12}},{"line":172,"address":[],"length":0,"stats":{"Line":12}},{"line":174,"address":[],"length":0,"stats":{"Line":36}},{"line":180,"address":[],"length":0,"stats":{"Line":36}},{"line":181,"address":[],"length":0,"stats":{"Line":36}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":36}},{"line":185,"address":[],"length":0,"stats":{"Line":24}},{"line":187,"address":[],"length":0,"stats":{"Line":84}},{"line":188,"address":[],"length":0,"stats":{"Line":108}},{"line":191,"address":[],"length":0,"stats":{"Line":24}},{"line":194,"address":[],"length":0,"stats":{"Line":120}},{"line":196,"address":[],"length":0,"stats":{"Line":120}},{"line":198,"address":[],"length":0,"stats":{"Line":12}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":28}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":28}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":290,"address":[],"length":0,"stats":{"Line":4}},{"line":291,"address":[],"length":0,"stats":{"Line":28}},{"line":296,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":28}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":28}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":323,"address":[],"length":0,"stats":{"Line":28}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":4}},{"line":338,"address":[],"length":0,"stats":{"Line":28}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":8}},{"line":368,"address":[],"length":0,"stats":{"Line":24}},{"line":373,"address":[],"length":0,"stats":{"Line":4}},{"line":383,"address":[],"length":0,"stats":{"Line":32}},{"line":389,"address":[],"length":0,"stats":{"Line":4}},{"line":399,"address":[],"length":0,"stats":{"Line":32}},{"line":408,"address":[],"length":0,"stats":{"Line":5}},{"line":417,"address":[],"length":0,"stats":{"Line":10}},{"line":419,"address":[],"length":0,"stats":{"Line":35}},{"line":425,"address":[],"length":0,"stats":{"Line":4}},{"line":434,"address":[],"length":0,"stats":{"Line":8}},{"line":436,"address":[],"length":0,"stats":{"Line":28}},{"line":442,"address":[],"length":0,"stats":{"Line":4}},{"line":451,"address":[],"length":0,"stats":{"Line":4}},{"line":452,"address":[],"length":0,"stats":{"Line":28}},{"line":458,"address":[],"length":0,"stats":{"Line":5}},{"line":468,"address":[],"length":0,"stats":{"Line":10}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":5}},{"line":479,"address":[],"length":0,"stats":{"Line":4}},{"line":489,"address":[],"length":0,"stats":{"Line":8}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":4}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":4}},{"line":548,"address":[],"length":0,"stats":{"Line":4}},{"line":549,"address":[],"length":0,"stats":{"Line":28}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":564,"address":[],"length":0,"stats":{"Line":4}},{"line":565,"address":[],"length":0,"stats":{"Line":28}},{"line":571,"address":[],"length":0,"stats":{"Line":4}},{"line":580,"address":[],"length":0,"stats":{"Line":4}},{"line":581,"address":[],"length":0,"stats":{"Line":28}},{"line":602,"address":[],"length":0,"stats":{"Line":2}},{"line":612,"address":[],"length":0,"stats":{"Line":2}},{"line":613,"address":[],"length":0,"stats":{"Line":14}}],"covered":88,"coverable":99},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","src","impl_mem_size.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\nuse core::marker::{PhantomData, PhantomPinned};\nuse core::num::*;\nuse core::sync::atomic::*;\n\nuse crate::{Boolean, CopyType, False, MemSize, SizeFlags, True};\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::string::String;\n\n#[cfg(feature = \"std\")]\n/// A basic implementation using [`core::mem::size_of`] for non-[`Copy`] types,\n/// setting [`CopyType::Copy`] to [`False`].\nmacro_rules! impl_size_of {\n    ($($ty:ty),*) =\u003e {$(\n        impl CopyType for $ty {\n            type Copy = False;\n        }\n\n        impl MemSize for $ty {\n            #[inline(always)]\n            fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n                core::mem::size_of::\u003cSelf\u003e()\n            }\n        }\n    )*};\n}\n\n/// A basic implementation using [`core::mem::size_of`] for [`Copy`] types,\n/// setting [`CopyType::Copy`] to [`True`].\nmacro_rules! impl_copy_size_of {\n    ($($ty:ty),*) =\u003e {$(\n        impl CopyType for $ty {\n            type Copy = True;\n        }\n\n        impl MemSize for $ty {\n            #[inline(always)]\n            fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n                core::mem::size_of::\u003cSelf\u003e()\n            }\n        }\n    )*};\n}\n\nimpl_copy_size_of! {\n   (), bool, char, f32, f64,\n   u8, u16, u32, u64, u128, usize,\n   i8, i16, i32, i64, i128, isize,\n   AtomicBool,\n   AtomicI8, AtomicI16, AtomicI32, AtomicI64, AtomicIsize,\n   AtomicU8, AtomicU16, AtomicU32, AtomicU64, AtomicUsize,\n   NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize,\n   NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize,\n   PhantomPinned\n}\n\n// Strings\n\nimpl CopyType for str {\n    type Copy = False;\n}\n\nimpl MemSize for str {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cusize\u003e() + self.len()\n    }\n}\n\nimpl CopyType for String {\n    type Copy = False;\n}\n\nimpl MemSize for String {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::CAPACITY) {\n            core::mem::size_of::\u003cSelf\u003e() + self.capacity()\n        } else {\n            core::mem::size_of::\u003cSelf\u003e() + self.len()\n        }\n    }\n}\n\n// PhantomData\n\nimpl\u003cT\u003e CopyType for PhantomData\u003cT\u003e {\n    type Copy = True;\n}\n\nimpl\u003cT: ?Sized\u003e MemSize for PhantomData\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        0\n    }\n}\n\n// References: we recurse only if FOLLOW_REFS is set\n\nimpl\u003cT: ?Sized + MemSize\u003e CopyType for \u0026'_ T {\n    type Copy = False;\n}\n\nimpl\u003cT: ?Sized + MemSize\u003e MemSize for \u0026'_ T {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            core::mem::size_of::\u003cSelf\u003e() + \u003cT as MemSize\u003e::mem_size(*self, flags)\n        } else {\n            core::mem::size_of::\u003cSelf\u003e()\n        }\n    }\n}\n\nimpl\u003cT: ?Sized + MemSize\u003e CopyType for \u0026'_ mut T {\n    type Copy = False;\n}\n\nimpl\u003cT: ?Sized + MemSize\u003e MemSize for \u0026'_ mut T {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003c\u0026'_ T as MemSize\u003e::mem_size(\u0026\u0026**self, flags)\n    }\n}\n\n// Option\n\nimpl\u003cT: CopyType + MemSize\u003e CopyType for Option\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for Option\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + self.as_ref().map_or(0, |x| {\n                \u003cT as MemSize\u003e::mem_size(x, flags) - core::mem::size_of::\u003cT\u003e()\n            })\n    }\n}\n\n// Box\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::boxed::Box;\nimpl\u003cT: ?Sized + MemSize\u003e MemSize for Box\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cT as MemSize\u003e::mem_size(self.as_ref(), flags)\n    }\n}\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::sync::Arc;\n#[cfg(feature = \"std\")]\nuse std::sync::Arc;\nimpl\u003cT: MemSize\u003e MemSize for Arc\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cT as MemSize\u003e::mem_size(self.as_ref(), flags)\n            - core::mem::size_of::\u003cT\u003e()\n    }\n}\n\n/// A helper trait that makes it possible to implement differently\n/// the size computation for arrays, vectors, and slices of\n/// [`Copy`] types.\n///\n/// See [`crate::CopyType`] for more information.\npub trait MemSizeHelper\u003cT: Boolean\u003e {\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize;\n}\n\n// Slices\n\nimpl\u003cT: CopyType\u003e MemSize for [T]\nwhere\n    [T]: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003c[T] as MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\u003e::mem_size_impl(self, flags)\n    }\n}\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::vec::Vec;\nimpl\u003cT: CopyType + MemSize\u003e MemSizeHelper\u003cTrue\u003e for [T] {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of_val(self)\n    }\n}\n\nimpl\u003cT: CopyType + MemSize\u003e MemSizeHelper\u003cFalse\u003e for [T] {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        self.iter()\n            .map(|x| \u003cT as MemSize\u003e::mem_size(x, flags))\n            .sum::\u003cusize\u003e()\n    }\n}\n\n// Arrays\n\nimpl\u003cT: CopyType + MemSize, const N: usize\u003e CopyType for [T; N] {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: CopyType, const N: usize\u003e MemSize for [T; N]\nwhere\n    [T; N]: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003c[T; N] as MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\u003e::mem_size_impl(self, flags)\n    }\n}\n\nimpl\u003cT: MemSize, const N: usize\u003e MemSizeHelper\u003cTrue\u003e for [T; N] {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cT: MemSize, const N: usize\u003e MemSizeHelper\u003cFalse\u003e for [T; N] {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + self\n                .iter()\n                .map(|x| \u003cT as MemSize\u003e::mem_size(x, flags) - core::mem::size_of::\u003cT\u003e())\n                .sum::\u003cusize\u003e()\n    }\n}\n\n// Vectors\n\nimpl\u003cT\u003e CopyType for Vec\u003cT\u003e {\n    type Copy = False;\n}\n\nimpl\u003cT: CopyType\u003e MemSize for Vec\u003cT\u003e\nwhere\n    Vec\u003cT\u003e: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003cVec\u003cT\u003e as MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\u003e::mem_size_impl(self, flags)\n    }\n}\n\nimpl\u003cT: CopyType + MemSize\u003e MemSizeHelper\u003cTrue\u003e for Vec\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::CAPACITY) {\n            core::mem::size_of::\u003cSelf\u003e() + self.capacity() * core::mem::size_of::\u003cT\u003e()\n        } else {\n            core::mem::size_of::\u003cSelf\u003e() + self.len() * core::mem::size_of::\u003cT\u003e()\n        }\n    }\n}\n\nimpl\u003cT: CopyType + MemSize\u003e MemSizeHelper\u003cFalse\u003e for Vec\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::CAPACITY) {\n            core::mem::size_of::\u003cSelf\u003e()\n                + self\n                    .iter()\n                    .map(|x| \u003cT as MemSize\u003e::mem_size(x, flags))\n                    .sum::\u003cusize\u003e()\n                + (self.capacity() - self.len()) * core::mem::size_of::\u003cT\u003e()\n        } else {\n            core::mem::size_of::\u003cSelf\u003e()\n                + self\n                    .iter()\n                    .map(|x| \u003cT as MemSize\u003e::mem_size(x, flags))\n                    .sum::\u003cusize\u003e()\n        }\n    }\n}\n\n// Tuples\n\nmacro_rules! impl_tuples_muncher {\n    () =\u003e {};\n\n    (($idx:tt =\u003e $ty:ident), $(($i:tt =\u003e $t:ident),)*) =\u003e {\n        // Pass to list reversal\n        impl_tuples_muncher!([($idx =\u003e $ty);] $(($i =\u003e $t),)*);\n        // Recurse on tail\n        impl_tuples_muncher!($(($i =\u003e $t),)*);\n    };\n\n    // List reversal\n    ([$(($accIdx: tt =\u003e $accTyp: ident);)+]  ($idx:tt =\u003e $typ:ident), $( ($nidx:tt =\u003e $ntyp:ident), )*) =\u003e {\n        impl_tuples_muncher!([($idx =\u003e $typ); $(($accIdx =\u003e $accTyp); )*] $( ($nidx =\u003e $ntyp), ) *);\n    };\n\n    // Implement on reversed list\n    ([($idx:tt =\u003e $ty:ident); $( ($nidx:tt =\u003e $nty:ident); )*]) =\u003e {\n        impl\u003c$ty, $($nty,)*\u003e CopyType for ($ty, $($nty,)*)  {\n            type Copy = False;\n\t\t}\n\n\t\timpl\u003c$ty: MemSize, $($nty: MemSize,)*\u003e MemSize for ($ty, $($nty,)*)\n        {\n            #[inline(always)]\n            fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n                let mut bytes = core::mem::size_of::\u003cSelf\u003e();\n                bytes += \u003c$ty as MemSize\u003e::mem_size(\u0026self.$idx, flags) - core::mem::size_of::\u003c$ty\u003e();\n                $( bytes += \u003c$nty as MemSize\u003e::mem_size(\u0026self.$nidx, flags) - core::mem::size_of::\u003c$nty\u003e(); )*\n                bytes\n            }\n        }\n    }\n\n}\n\nimpl_tuples_muncher!(\n    (9 =\u003e T9),\n    (8 =\u003e T8),\n    (7 =\u003e T7),\n    (6 =\u003e T6),\n    (5 =\u003e T5),\n    (4 =\u003e T4),\n    (3 =\u003e T3),\n    (2 =\u003e T2),\n    (1 =\u003e T1),\n    (0 =\u003e T0),\n);\n\n// Functions\n\nimpl\u003cR\u003e CopyType for fn() -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cR\u003e MemSize for fn() -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cA, R\u003e CopyType for fn(A) -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cA, R\u003e MemSize for fn(A) -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cA, B, R\u003e CopyType for fn(A, B) -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cA, B, R\u003e MemSize for fn(A, B) -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cA, B, C, R\u003e CopyType for fn(A, B, C) -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cA, B, C, R\u003e MemSize for fn(A, B, C) -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\nimpl\u003cA, B, C, D, R\u003e CopyType for fn(A, B, C, D) -\u003e R {\n    type Copy = True;\n}\n\nimpl\u003cA, B, C, D, R\u003e MemSize for fn(A, B, C, D) -\u003e R {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\n// Ranges\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::Range\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::Range\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + \u003cIdx as MemSize\u003e::mem_size(\u0026self.start, flags)\n            + \u003cIdx as MemSize\u003e::mem_size(\u0026self.end, flags)\n            - 2 * core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::RangeFrom\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::RangeFrom\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cIdx as MemSize\u003e::mem_size(\u0026self.start, flags)\n            - core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::RangeInclusive\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::RangeInclusive\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + \u003cIdx as MemSize\u003e::mem_size(self.start(), flags)\n            + \u003cIdx as MemSize\u003e::mem_size(self.end(), flags)\n            - 2 * core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::RangeTo\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::RangeTo\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cIdx as MemSize\u003e::mem_size(\u0026self.end, flags)\n            - core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\nimpl\u003cIdx: CopyType\u003e CopyType for core::ops::RangeToInclusive\u003cIdx\u003e {\n    type Copy = True;\n}\n\nimpl\u003cIdx: MemSize\u003e MemSize for core::ops::RangeToInclusive\u003cIdx\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + \u003cIdx as MemSize\u003e::mem_size(\u0026self.end, flags)\n            - core::mem::size_of::\u003cIdx\u003e()\n    }\n}\n\n// Rand crate\n\n#[cfg(feature = \"rand\")]\nimpl_copy_size_of!(\n    rand::rngs::SmallRng,\n    rand::rngs::ThreadRng,\n    rand::rngs::StdRng\n);\n\n// Cells\n\nimpl\u003cT: CopyType\u003e CopyType for core::cell::RefCell\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for core::cell::RefCell\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(\u0026self.borrow(), flags)\n    }\n}\n\nimpl\u003cT: CopyType\u003e CopyType for core::cell::Cell\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for core::cell::Cell\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + unsafe { \u003cT as MemSize\u003e::mem_size(\u0026*self.as_ptr(), flags) }\n    }\n}\n\nimpl\u003cT: CopyType\u003e CopyType for core::cell::OnceCell\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for core::cell::OnceCell\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cOption\u003c\u0026T\u003e as MemSize\u003e::mem_size(\u0026self.get(), flags)\n    }\n}\n\nimpl\u003cT: CopyType\u003e CopyType for core::cell::UnsafeCell\u003cT\u003e {\n    type Copy = T::Copy;\n}\n\nimpl\u003cT: MemSize\u003e MemSize for core::cell::UnsafeCell\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() + unsafe { \u003cT as MemSize\u003e::mem_size(\u0026*self.get(), flags) }\n            - core::mem::size_of::\u003cT\u003e()\n    }\n}\n\n// Mutexes\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::Mutex\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::Mutex\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(\u0026self.lock().unwrap(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::RwLock\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::RwLock\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(\u0026self.read().unwrap(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::MutexGuard\u003c'_, T\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::MutexGuard\u003c'_, T\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        use core::ops::Deref;\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n                + \u003cT as MemSize\u003e::mem_size(self.deref(), flags)\n        } else {\n            0\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::RwLockReadGuard\u003c'_, T\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::RwLockReadGuard\u003c'_, T\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        use core::ops::Deref;\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n                + \u003cT as MemSize\u003e::mem_size(self.deref(), flags)\n        } else {\n            0\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e CopyType for std::sync::RwLockWriteGuard\u003c'_, T\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::sync::RwLockWriteGuard\u003c'_, T\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        use core::ops::Deref;\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n                + \u003cT as MemSize\u003e::mem_size(self.deref(), flags)\n        } else {\n            0\n        }\n    }\n}\n\n// OS stuff\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::path::Path {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::path::Path {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003cstd::ffi::OsStr as MemSize\u003e::mem_size(self.as_os_str(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::path::PathBuf {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::path::PathBuf {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + if flags.contains(SizeFlags::CAPACITY) {\n                self.capacity()\n            } else {\n                \u003cstd::ffi::OsStr as MemSize\u003e::mem_size(self.as_os_str(), flags)\n            }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::ffi::OsStr {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::ffi::OsStr {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        if flags.contains(SizeFlags::FOLLOW_REFS) {\n            // OsStr is unsized, so we can only return the length of the data\n            self.as_encoded_bytes().len()\n        } else {\n            0\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::ffi::OsString {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::ffi::OsString {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        // OsString is like String - it has heap-allocated data\n        // We use len() by default, and capacity() with CAPACITY flag\n        core::mem::size_of::\u003cSelf\u003e()\n            + if flags.contains(SizeFlags::CAPACITY) {\n                self.capacity()\n            } else {\n                self.len()\n            }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl_size_of!(\n    std::fs::File,\n    std::fs::OpenOptions,\n    std::fs::Metadata,\n    std::fs::FileType,\n    std::fs::FileTimes,\n    std::fs::Permissions\n);\n\n// I/O\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize + std::io::Read\u003e CopyType for std::io::BufReader\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize + std::io::Read\u003e MemSize for std::io::BufReader\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(self.get_ref(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize + std::io::Write\u003e CopyType for std::io::BufWriter\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize + std::io::Write\u003e MemSize for std::io::BufWriter\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(self.get_ref(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT\u003e CopyType for std::io::Cursor\u003cT\u003e {\n    type Copy = False;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: MemSize\u003e MemSize for std::io::Cursor\u003cT\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(self.get_ref(), flags)\n    }\n}\n\n// IpAddr\n#[cfg(feature = \"std\")]\nimpl_copy_size_of!(\n    std::net::Ipv4Addr,\n    std::net::Ipv6Addr,\n    std::net::IpAddr,\n    std::net::SocketAddrV4,\n    std::net::SocketAddrV6,\n    std::net::SocketAddr\n);\n\n// Time\n#[cfg(feature = \"std\")]\nimpl_copy_size_of!(\n    std::time::Duration,\n    std::time::Instant,\n    std::time::SystemTime,\n    std::time::SystemTimeError\n);\n\n// mmap-rs crate\n\n#[cfg(feature = \"mmap-rs\")]\nimpl CopyType for mmap_rs::Mmap {\n    type Copy = False;\n}\n\n#[cfg(feature = \"mmap-rs\")]\nimpl MemSize for mmap_rs::Mmap {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + if flags.contains(SizeFlags::FOLLOW_REFS) {\n                self.len()\n            } else {\n                0\n            }\n    }\n}\n\n#[cfg(feature = \"mmap-rs\")]\nimpl CopyType for mmap_rs::MmapMut {\n    type Copy = False;\n}\n\n#[cfg(feature = \"mmap-rs\")]\nimpl MemSize for mmap_rs::MmapMut {\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n            + if flags.contains(SizeFlags::FOLLOW_REFS) {\n                self.len()\n            } else {\n                0\n            }\n    }\n}\n\n#[cfg(feature = \"std\")]\n// Hash-based containers from the standard library\n//\n// If the standard library changes load factor, this code will have to change\n// accordingly.\n\n// Straight from hashbrown\nfn capacity_to_buckets(cap: usize) -\u003e Option\u003cusize\u003e {\n    // TODO: check that cap == 0 is handled correctly (we presently return 4)\n\n    // For small tables we require at least 1 empty bucket so that lookups are\n    // guaranteed to terminate if an element doesn't exist in the table.\n    if cap \u003c 8 {\n        // We don't bother with a table size of 2 buckets since that can only\n        // hold a single element. Instead we skip directly to a 4 bucket table\n        // which can hold 3 elements.\n        return Some(if cap \u003c 4 { 4 } else { 8 });\n    }\n\n    // Otherwise require 1/8 buckets to be empty (87.5% load)\n    //\n    // Be careful when modifying this, calculate_layout relies on the\n    // overflow check here.\n    let adjusted_cap = cap.checked_mul(8)? / 7;\n\n    // Any overflows will have been caught by the checked_mul. Also, any\n    // rounding errors from the division above will be cleaned up by\n    // next_power_of_two (which can't overflow because of the previous division).\n    Some(adjusted_cap.next_power_of_two())\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT: CopyType\u003e MemSize for std::collections::HashSet\u003cT\u003e\nwhere\n    std::collections::HashSet\u003cT\u003e: MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003cstd::collections::HashSet\u003cT\u003e as MemSizeHelper\u003c\u003cT as CopyType\u003e::Copy\u003e\u003e::mem_size_impl(\n            self, flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\n// Add to the given size the space occupied on the stack by the hash set, by the unused\n// but unavoidable buckets, by the speedup bytes of Swiss Tables, and if `flags` contains\n// `SizeFlags::CAPACITY`, by empty buckets.\nfn fix_set_for_capacity\u003cK\u003e(\n    hash_set: \u0026std::collections::HashSet\u003cK\u003e,\n    size: usize,\n    flags: SizeFlags,\n) -\u003e usize {\n    core::mem::size_of::\u003cstd::collections::HashSet\u003cK\u003e\u003e()\n        + size\n        + if flags.contains(SizeFlags::CAPACITY) {\n            (capacity_to_buckets(hash_set.capacity()).unwrap_or(usize::MAX) - hash_set.len())\n                * core::mem::size_of::\u003cK\u003e()\n                + capacity_to_buckets(hash_set.capacity()).unwrap_or(usize::MAX)\n                    * core::mem::size_of::\u003cu8\u003e()\n        } else {\n            (capacity_to_buckets(hash_set.len()).unwrap_or(usize::MAX) - hash_set.len())\n                * core::mem::size_of::\u003cK\u003e()\n                + capacity_to_buckets(hash_set.len()).unwrap_or(usize::MAX)\n                    * core::mem::size_of::\u003cu8\u003e()\n        }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize\u003e MemSizeHelper\u003cTrue\u003e for std::collections::HashSet\u003cK\u003e {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_set_for_capacity(self, core::mem::size_of::\u003cK\u003e() * self.len(), flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize\u003e MemSizeHelper\u003cFalse\u003e for std::collections::HashSet\u003cK\u003e {\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_set_for_capacity(\n            self,\n            self.iter()\n                .map(|x| \u003cK as MemSize\u003e::mem_size(x, flags))\n                .sum::\u003cusize\u003e(),\n            flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\n/// A helper trait that makes it possible to implement differently\n/// the size computation for maps in which keys or values are\n/// [`Copy`] types.\n///\n/// See [`crate::CopyType`] for more information.\npub trait MemSizeHelper2\u003cK: Boolean, V: Boolean\u003e {\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize;\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType, V: CopyType\u003e MemSize for std::collections::HashMap\u003cK, V\u003e\nwhere\n    std::collections::HashMap\u003cK, V\u003e: MemSizeHelper2\u003c\u003cK as CopyType\u003e::Copy, \u003cV as CopyType\u003e::Copy\u003e,\n{\n    #[inline(always)]\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        \u003cstd::collections::HashMap\u003cK, V\u003e as MemSizeHelper2\u003c\n            \u003cK as CopyType\u003e::Copy,\n            \u003cV as CopyType\u003e::Copy,\n        \u003e\u003e::mem_size_impl(self, flags)\n    }\n}\n\n#[cfg(feature = \"std\")]\n// Add to the given size the space occupied on the stack by the hash map, by the unused\n// but unavoidable buckets, by the speedup bytes of Swiss Tables, and if `flags` contains\n// `SizeFlags::CAPACITY`, by empty buckets.\nfn fix_map_for_capacity\u003cK, V\u003e(\n    hash_map: \u0026std::collections::HashMap\u003cK, V\u003e,\n    size: usize,\n    flags: SizeFlags,\n) -\u003e usize {\n    core::mem::size_of::\u003cstd::collections::HashSet\u003cK\u003e\u003e()\n        + size\n        + if flags.contains(SizeFlags::CAPACITY) {\n            (capacity_to_buckets(hash_map.capacity()).unwrap_or(usize::MAX) - hash_map.len())\n                * (core::mem::size_of::\u003cK\u003e() + core::mem::size_of::\u003cV\u003e())\n                + capacity_to_buckets(hash_map.capacity()).unwrap_or(usize::MAX)\n                    * core::mem::size_of::\u003cu8\u003e()\n        } else {\n            (capacity_to_buckets(hash_map.len()).unwrap_or(usize::MAX) - hash_map.len())\n                * (core::mem::size_of::\u003cK\u003e() + core::mem::size_of::\u003cV\u003e())\n                + capacity_to_buckets(hash_map.len()).unwrap_or(usize::MAX)\n                    * core::mem::size_of::\u003cu8\u003e()\n        }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize, V: CopyType + MemSize\u003e MemSizeHelper2\u003cTrue, True\u003e\n    for std::collections::HashMap\u003cK, V\u003e\n{\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_map_for_capacity(\n            self,\n            (core::mem::size_of::\u003cK\u003e() + core::mem::size_of::\u003cV\u003e()) * self.len(),\n            flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize, V: CopyType + MemSize\u003e MemSizeHelper2\u003cTrue, False\u003e\n    for std::collections::HashMap\u003cK, V\u003e\n{\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_map_for_capacity(\n            self,\n            (core::mem::size_of::\u003cK\u003e()) * self.len()\n                + self\n                    .values()\n                    .map(|v| \u003cV as MemSize\u003e::mem_size(v, flags))\n                    .sum::\u003cusize\u003e(),\n            flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize, V: CopyType + MemSize\u003e MemSizeHelper2\u003cFalse, True\u003e\n    for std::collections::HashMap\u003cK, V\u003e\n{\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_map_for_capacity(\n            self,\n            self.keys()\n                .map(|k| \u003cK as MemSize\u003e::mem_size(k, flags))\n                .sum::\u003cusize\u003e()\n                + (core::mem::size_of::\u003cV\u003e()) * self.len(),\n            flags,\n        )\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cK: CopyType + MemSize, V: CopyType + MemSize\u003e MemSizeHelper2\u003cFalse, False\u003e\n    for std::collections::HashMap\u003cK, V\u003e\n{\n    #[inline(always)]\n    fn mem_size_impl(\u0026self, flags: SizeFlags) -\u003e usize {\n        fix_map_for_capacity(\n            self,\n            self.iter()\n                .map(|(k, v)| {\n                    \u003cK as MemSize\u003e::mem_size(k, flags) + \u003cV as MemSize\u003e::mem_size(v, flags)\n                })\n                .sum::\u003cusize\u003e(),\n            flags,\n        )\n    }\n}\n\n// Hash\n\nimpl\u003cH\u003e CopyType for core::hash::BuildHasherDefault\u003cH\u003e {\n    type Copy = True;\n}\nimpl\u003cH\u003e MemSize for core::hash::BuildHasherDefault\u003cH\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        // it's a phantom hash\n        debug_assert_eq!(core::mem::size_of::\u003cSelf\u003e(), 0);\n        0\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::hash::DefaultHasher {\n    type Copy = True;\n}\n\n#[cfg(feature = \"std\")]\n// This implementation assumes that DefaultHasher is a fixed-size type\n// that does not allocate memory on the heap.\nimpl MemSize for std::hash::DefaultHasher {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl CopyType for std::collections::hash_map::RandomState {\n    type Copy = True;\n}\n\n#[cfg(feature = \"std\")]\nimpl MemSize for std::collections::hash_map::RandomState {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\n// Memory stuff\n\nimpl_copy_size_of!(core::alloc::Layout);\n\nimpl\u003cT: ?Sized\u003e CopyType for core::ptr::NonNull\u003cT\u003e {\n    type Copy = True;\n}\n\nimpl\u003cT: ?Sized\u003e MemSize for core::ptr::NonNull\u003cT\u003e {\n    #[inline(always)]\n    fn mem_size(\u0026self, _flags: SizeFlags) -\u003e usize {\n        core::mem::size_of::\u003cSelf\u003e()\n    }\n}\n\n// maligned crate\n\n#[cfg(feature = \"maligned\")]\nimpl_copy_size_of!(\n    maligned::A2,\n    maligned::A4,\n    maligned::A8,\n    maligned::A16,\n    maligned::A32,\n    maligned::A64,\n    maligned::A128,\n    maligned::A256,\n    maligned::A512\n);\n\n#[cfg(feature = \"maligned\")]\nimpl\u003cA: maligned::Alignment, T: MemSize\u003e CopyType for maligned::Aligned\u003cA, T\u003e {\n    type Copy = True;\n}\n\n#[cfg(feature = \"maligned\")]\nimpl\u003cA: maligned::Alignment, T: MemSize\u003e MemSize for maligned::Aligned\u003cA, T\u003e {\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize {\n        use core::ops::Deref;\n        core::mem::size_of::\u003cSelf\u003e() - core::mem::size_of::\u003cT\u003e()\n            + \u003cT as MemSize\u003e::mem_size(self.deref(), flags)\n    }\n}\n\n// half crate\n\n#[cfg(feature = \"half\")]\nimpl_copy_size_of!(half::f16, half::bf16);\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":30,"address":[],"length":0,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":916}},{"line":47,"address":[],"length":0,"stats":{"Line":916}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":18}},{"line":85,"address":[],"length":0,"stats":{"Line":36}},{"line":86,"address":[],"length":0,"stats":{"Line":14}},{"line":88,"address":[],"length":0,"stats":{"Line":22}},{"line":101,"address":[],"length":0,"stats":{"Line":15}},{"line":102,"address":[],"length":0,"stats":{"Line":15}},{"line":114,"address":[],"length":0,"stats":{"Line":140}},{"line":115,"address":[],"length":0,"stats":{"Line":280}},{"line":116,"address":[],"length":0,"stats":{"Line":150}},{"line":118,"address":[],"length":0,"stats":{"Line":90}},{"line":129,"address":[],"length":0,"stats":{"Line":62}},{"line":130,"address":[],"length":0,"stats":{"Line":186}},{"line":142,"address":[],"length":0,"stats":{"Line":57}},{"line":143,"address":[],"length":0,"stats":{"Line":57}},{"line":144,"address":[],"length":0,"stats":{"Line":221}},{"line":145,"address":[],"length":0,"stats":{"Line":150}},{"line":156,"address":[],"length":0,"stats":{"Line":20}},{"line":157,"address":[],"length":0,"stats":{"Line":60}},{"line":167,"address":[],"length":0,"stats":{"Line":18}},{"line":168,"address":[],"length":0,"stats":{"Line":54}},{"line":169,"address":[],"length":0,"stats":{"Line":18}},{"line":189,"address":[],"length":0,"stats":{"Line":26}},{"line":190,"address":[],"length":0,"stats":{"Line":78}},{"line":198,"address":[],"length":0,"stats":{"Line":20}},{"line":199,"address":[],"length":0,"stats":{"Line":40}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[],"length":0,"stats":{"Line":12}},{"line":207,"address":[],"length":0,"stats":{"Line":186}},{"line":223,"address":[],"length":0,"stats":{"Line":20}},{"line":224,"address":[],"length":0,"stats":{"Line":60}},{"line":230,"address":[],"length":0,"stats":{"Line":17}},{"line":231,"address":[],"length":0,"stats":{"Line":17}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":123}},{"line":242,"address":[],"length":0,"stats":{"Line":3}},{"line":257,"address":[],"length":0,"stats":{"Line":49}},{"line":258,"address":[],"length":0,"stats":{"Line":147}},{"line":264,"address":[],"length":0,"stats":{"Line":32}},{"line":265,"address":[],"length":0,"stats":{"Line":64}},{"line":266,"address":[],"length":0,"stats":{"Line":36}},{"line":268,"address":[],"length":0,"stats":{"Line":60}},{"line":275,"address":[],"length":0,"stats":{"Line":17}},{"line":276,"address":[],"length":0,"stats":{"Line":34}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":16}},{"line":285,"address":[],"length":0,"stats":{"Line":16}},{"line":286,"address":[],"length":0,"stats":{"Line":16}},{"line":287,"address":[],"length":0,"stats":{"Line":121}},{"line":288,"address":[],"length":0,"stats":{"Line":16}},{"line":319,"address":[],"length":0,"stats":{"Line":46}},{"line":320,"address":[],"length":0,"stats":{"Line":92}},{"line":321,"address":[],"length":0,"stats":{"Line":138}},{"line":322,"address":[],"length":0,"stats":{"Line":138}},{"line":323,"address":[],"length":0,"stats":{"Line":46}},{"line":351,"address":[],"length":0,"stats":{"Line":14}},{"line":352,"address":[],"length":0,"stats":{"Line":14}},{"line":362,"address":[],"length":0,"stats":{"Line":14}},{"line":363,"address":[],"length":0,"stats":{"Line":14}},{"line":373,"address":[],"length":0,"stats":{"Line":14}},{"line":374,"address":[],"length":0,"stats":{"Line":14}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":14}},{"line":409,"address":[],"length":0,"stats":{"Line":42}},{"line":410,"address":[],"length":0,"stats":{"Line":42}},{"line":411,"address":[],"length":0,"stats":{"Line":28}},{"line":412,"address":[],"length":0,"stats":{"Line":14}},{"line":422,"address":[],"length":0,"stats":{"Line":14}},{"line":423,"address":[],"length":0,"stats":{"Line":42}},{"line":424,"address":[],"length":0,"stats":{"Line":14}},{"line":434,"address":[],"length":0,"stats":{"Line":14}},{"line":435,"address":[],"length":0,"stats":{"Line":42}},{"line":436,"address":[],"length":0,"stats":{"Line":42}},{"line":437,"address":[],"length":0,"stats":{"Line":28}},{"line":438,"address":[],"length":0,"stats":{"Line":14}},{"line":448,"address":[],"length":0,"stats":{"Line":14}},{"line":449,"address":[],"length":0,"stats":{"Line":42}},{"line":450,"address":[],"length":0,"stats":{"Line":14}},{"line":460,"address":[],"length":0,"stats":{"Line":14}},{"line":461,"address":[],"length":0,"stats":{"Line":42}},{"line":462,"address":[],"length":0,"stats":{"Line":14}},{"line":482,"address":[],"length":0,"stats":{"Line":14}},{"line":483,"address":[],"length":0,"stats":{"Line":28}},{"line":484,"address":[],"length":0,"stats":{"Line":28}},{"line":493,"address":[],"length":0,"stats":{"Line":14}},{"line":494,"address":[],"length":0,"stats":{"Line":28}},{"line":495,"address":[],"length":0,"stats":{"Line":28}},{"line":504,"address":[],"length":0,"stats":{"Line":14}},{"line":505,"address":[],"length":0,"stats":{"Line":28}},{"line":506,"address":[],"length":0,"stats":{"Line":28}},{"line":515,"address":[],"length":0,"stats":{"Line":15}},{"line":516,"address":[],"length":0,"stats":{"Line":45}},{"line":517,"address":[],"length":0,"stats":{"Line":15}},{"line":530,"address":[],"length":0,"stats":{"Line":18}},{"line":531,"address":[],"length":0,"stats":{"Line":36}},{"line":532,"address":[],"length":0,"stats":{"Line":54}},{"line":543,"address":[],"length":0,"stats":{"Line":14}},{"line":544,"address":[],"length":0,"stats":{"Line":28}},{"line":545,"address":[],"length":0,"stats":{"Line":42}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":15}},{"line":625,"address":[],"length":0,"stats":{"Line":15}},{"line":626,"address":[],"length":0,"stats":{"Line":30}},{"line":627,"address":[],"length":0,"stats":{"Line":14}},{"line":629,"address":[],"length":0,"stats":{"Line":24}},{"line":641,"address":[],"length":0,"stats":{"Line":8}},{"line":642,"address":[],"length":0,"stats":{"Line":16}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":8}},{"line":658,"address":[],"length":0,"stats":{"Line":14}},{"line":661,"address":[],"length":0,"stats":{"Line":14}},{"line":662,"address":[],"length":0,"stats":{"Line":28}},{"line":663,"address":[],"length":0,"stats":{"Line":14}},{"line":665,"address":[],"length":0,"stats":{"Line":7}},{"line":689,"address":[],"length":0,"stats":{"Line":14}},{"line":690,"address":[],"length":0,"stats":{"Line":28}},{"line":691,"address":[],"length":0,"stats":{"Line":28}},{"line":702,"address":[],"length":0,"stats":{"Line":14}},{"line":703,"address":[],"length":0,"stats":{"Line":28}},{"line":704,"address":[],"length":0,"stats":{"Line":28}},{"line":715,"address":[],"length":0,"stats":{"Line":14}},{"line":716,"address":[],"length":0,"stats":{"Line":28}},{"line":717,"address":[],"length":0,"stats":{"Line":28}},{"line":751,"address":[],"length":0,"stats":{"Line":4}},{"line":752,"address":[],"length":0,"stats":{"Line":4}},{"line":753,"address":[],"length":0,"stats":{"Line":8}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":4}},{"line":769,"address":[],"length":0,"stats":{"Line":4}},{"line":770,"address":[],"length":0,"stats":{"Line":4}},{"line":771,"address":[],"length":0,"stats":{"Line":8}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":4}},{"line":786,"address":[],"length":0,"stats":{"Line":56}},{"line":791,"address":[],"length":0,"stats":{"Line":56}},{"line":795,"address":[],"length":0,"stats":{"Line":112}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":14}},{"line":818,"address":[],"length":0,"stats":{"Line":28}},{"line":827,"address":[],"length":0,"stats":{"Line":14}},{"line":832,"address":[],"length":0,"stats":{"Line":14}},{"line":833,"address":[],"length":0,"stats":{"Line":14}},{"line":834,"address":[],"length":0,"stats":{"Line":28}},{"line":835,"address":[],"length":0,"stats":{"Line":42}},{"line":836,"address":[],"length":0,"stats":{"Line":14}},{"line":837,"address":[],"length":0,"stats":{"Line":28}},{"line":838,"address":[],"length":0,"stats":{"Line":7}},{"line":840,"address":[],"length":0,"stats":{"Line":42}},{"line":841,"address":[],"length":0,"stats":{"Line":14}},{"line":842,"address":[],"length":0,"stats":{"Line":28}},{"line":843,"address":[],"length":0,"stats":{"Line":7}},{"line":850,"address":[],"length":0,"stats":{"Line":14}},{"line":851,"address":[],"length":0,"stats":{"Line":70}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":14}},{"line":889,"address":[],"length":0,"stats":{"Line":42}},{"line":897,"address":[],"length":0,"stats":{"Line":14}},{"line":902,"address":[],"length":0,"stats":{"Line":14}},{"line":903,"address":[],"length":0,"stats":{"Line":14}},{"line":904,"address":[],"length":0,"stats":{"Line":28}},{"line":905,"address":[],"length":0,"stats":{"Line":49}},{"line":906,"address":[],"length":0,"stats":{"Line":14}},{"line":907,"address":[],"length":0,"stats":{"Line":28}},{"line":908,"address":[],"length":0,"stats":{"Line":7}},{"line":910,"address":[],"length":0,"stats":{"Line":49}},{"line":911,"address":[],"length":0,"stats":{"Line":14}},{"line":912,"address":[],"length":0,"stats":{"Line":28}},{"line":913,"address":[],"length":0,"stats":{"Line":7}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":14}},{"line":956,"address":[],"length":0,"stats":{"Line":14}},{"line":957,"address":[],"length":0,"stats":{"Line":28}},{"line":958,"address":[],"length":0,"stats":{"Line":98}},{"line":959,"address":[],"length":0,"stats":{"Line":14}},{"line":960,"address":[],"length":0,"stats":{"Line":28}},{"line":961,"address":[],"length":0,"stats":{"Line":14}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":14}},{"line":993,"address":[],"length":0,"stats":{"Line":14}},{"line":994,"address":[],"length":0,"stats":{"Line":14}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":14}},{"line":1022,"address":[],"length":0,"stats":{"Line":14}},{"line":1036,"address":[],"length":0,"stats":{"Line":14}},{"line":1037,"address":[],"length":0,"stats":{"Line":14}},{"line":1063,"address":[],"length":0,"stats":{"Line":8}},{"line":1065,"address":[],"length":0,"stats":{"Line":16}},{"line":1066,"address":[],"length":0,"stats":{"Line":16}}],"covered":189,"coverable":244},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","src","lib.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n#![cfg_attr(feature = \"offset_of_enum\", feature(offset_of_enum))]\n#![doc = include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/README.md\"))]\n#![deny(unconditional_recursion)]\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#[cfg(not(feature = \"std\"))]\nextern crate alloc;\n\n#[cfg(not(feature = \"std\"))]\nuse alloc::string::String;\n\n#[cfg(feature = \"derive\")]\npub use mem_dbg_derive::{MemDbg, MemSize};\n\nmod impl_mem_dbg;\nmod impl_mem_size;\n\nmod utils;\npub use utils::*;\n\n/**\n\nInternal trait used within [`CopyType`] to implement [`MemSize`] depending\non whether a type is [`Copy`] or not.\n\nIt has only two implementations, [`True`] and [`False`].\n\n*/\npub trait Boolean {}\n/// One of the two possible implementations of [`Boolean`].\npub struct True {}\nimpl Boolean for True {}\n/// One of the two possible implementations of [`Boolean`].\npub struct False {}\nimpl Boolean for False {}\n\n/**\n\nMarker trait for copy types.\n\nThe trait comes in two flavors: `CopyType\u003cCopy=True\u003e` and\n`CopyType\u003cCopy=False\u003e`. In the first case, [`MemSize::mem_size`] can be computed on\narrays, vectors, and slices by multiplying the length or capacity\nby the size of the element type; in the second case, it\nis necessary to iterate on each element.\n\nThe trait is made necessary by the impossibility of checking that a type\nimplements [`Copy`] from a procedural macro.\n\nSince we cannot use negative trait bounds, every type that is used as a parameter of\nan array, vector, or slice must implement either `CopyType\u003cCopy=True\u003e` or\n`CopyType\u003cCopy=False\u003e`.  If you do not implement either of these traits,\nyou will not be able to compute the size of arrays, vectors, and slices but error\nmessages will be very unhelpful due to the contrived way we have to implement\nmutually exclusive types [working around the bug that prevents the compiler\nfrom understanding that implementations for the two flavors of `CopyType` are mutually\nexclusive](https://github.com/rust-lang/rfcs/pull/1672#issuecomment-1405377983).\n\nIf you use the provided derive macros all this logic will be hidden from you. You'll\njust have to add the attribute `#[copy_type]` to your structures if they\nare [`Copy`] types and they do not contain non-`'static` references. We enforce this property by\nadding a bound `Copy + 'static` to the type in the procedural macro.\n\nNote that this approach forces us to compute the size of [`Copy`] types that contain\nreferences by iteration _even if you do not specify_ [`SizeFlags::FOLLOW_REFS`].\n\n*/\npub trait CopyType {\n    type Copy: Boolean;\n}\n\nbitflags::bitflags! {\n    /// Flags for [`MemDbg`].\n    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct SizeFlags: u32 {\n        /// Follow references.\n        ///\n        /// By default [`MemSize::mem_size`] does not follow references and\n        /// computes only the size of the reference itself.\n        ///\n        /// # Warning\n        ///\n        /// Note that all references are followed independently. If the same\n        /// region of memory is reachable by two different paths, it will be\n        /// counted twice.\n        const FOLLOW_REFS = 1 \u003c\u003c 0;\n        /// Return capacity instead of size.\n        ///\n        /// Size does not include memory allocated but not used: for example, in\n        /// the case of a vector [`MemSize::mem_size`] calls [`Vec::len`] rather\n        /// than [`Vec::capacity`].\n        ///\n        /// However, when this flag is specified [`MemSize::mem_size`] will\n        /// return the size of all memory allocated, even if it is not used: for\n        /// example, in the case of a vector this option makes\n        /// [`MemSize::mem_size`] call [`Vec::capacity`] rather than\n        /// [`Vec::len`].\n        const CAPACITY = 1 \u003c\u003c 1;\n    }\n}\n\nimpl Default for SizeFlags {\n    /// The default set of flags is the empty set.\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::empty()\n    }\n}\n\n/// A trait to compute recursively the overall size or capacity of a structure,\n/// as opposed to the stack size returned by [`core::mem::size_of()`].\n///\n/// You can derive this trait with `#[derive(MemSize)]` if all the fields of\n/// your type implement [`MemSize`].\npub trait MemSize {\n    /// Returns the (recursively computed) overall\n    /// memory size of the structure in bytes.\n    fn mem_size(\u0026self, flags: SizeFlags) -\u003e usize;\n}\n\nbitflags::bitflags! {\n    /// Flags for [`MemDbg`].\n    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n    pub struct DbgFlags: u32 {\n        /// Follow references. See [`SizeFlags::FOLLOW_REFS`].\n        const FOLLOW_REFS = 1 \u003c\u003c 0;\n        /// Print memory usage in human readable format.\n        const HUMANIZE = 1 \u003c\u003c 1;\n        /// Print memory usage as a percentage.\n        const PERCENTAGE = 1 \u003c\u003c 2;\n        /// Print the type name.\n        const TYPE_NAME = 1 \u003c\u003c 3;\n        /// Display capacity instead of size. See [`SizeFlags::CAPACITY`].\n        const CAPACITY = 1 \u003c\u003c 4;\n        /// Add an underscore every 3 digits, when `HUMANIZE` is not set.\n        const SEPARATOR = 1 \u003c\u003c 5;\n        /// Print fields in memory order (i.e., using the layout chosen by the\n        /// compiler), rather than in declaration order.\n        const RUST_LAYOUT = 1 \u003c\u003c 6;\n        /// Use colors to distinguish sizes.\n        const COLOR = 1 \u003c\u003c 7;\n    }\n}\n\nimpl DbgFlags {\n    /// Translates flags that are in common with [`MemSize`] into [`SizeFlags`].\n    pub fn to_size_flags(\u0026self) -\u003e SizeFlags {\n        let mut flags = SizeFlags::empty();\n        if self.contains(DbgFlags::FOLLOW_REFS) {\n            flags |= SizeFlags::FOLLOW_REFS;\n        }\n        if self.contains(DbgFlags::CAPACITY) {\n            flags |= SizeFlags::CAPACITY;\n        }\n        flags\n    }\n}\n\nimpl Default for DbgFlags {\n    /// The default set of flags contains [`DbgFlags::TYPE_NAME`],\n    /// [`DbgFlags::SEPARATOR`], and [`DbgFlags::PERCENTAGE`].\n    #[inline(always)]\n    fn default() -\u003e Self {\n        Self::TYPE_NAME | Self::SEPARATOR | Self::PERCENTAGE\n    }\n}\n\n/// A trait providing methods to display recursively the content and size of a\n/// structure.\n///\n/// You can derive this trait with `#[derive(MemDbg)]` if all the fields of your\n/// type implement [`MemDbg`]. Note that you will also need to derive\n/// [`MemSize`].\npub trait MemDbg: MemDbgImpl {\n    /// Writes to stderr debug infos about the structure memory usage, expanding\n    /// all levels of nested structures.\n    #[inline(always)]\n    #[cfg(feature = \"std\")]\n    fn mem_dbg(\u0026self, flags: DbgFlags) -\u003e core::fmt::Result {\n        // TODO: fix padding\n        self._mem_dbg_depth(\n            \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags()),\n            usize::MAX,\n            core::mem::size_of_val(self),\n            flags,\n        )\n    }\n\n    /// Writes to a [`core::fmt::Write`] debug infos about the structure memory\n    /// usage, expanding all levels of nested structures.\n    #[inline(always)]\n    fn mem_dbg_on(\u0026self, writer: \u0026mut impl core::fmt::Write, flags: DbgFlags) -\u003e core::fmt::Result {\n        // TODO: fix padding\n        self._mem_dbg_depth_on(\n            writer,\n            \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags()),\n            usize::MAX,\n            \u0026mut String::new(),\n            Some(\"\"),\n            true,\n            core::mem::size_of_val(self),\n            flags,\n        )\n    }\n\n    #[cfg(feature = \"std\")]\n    /// Writes to stderr debug infos about the structure memory usage as\n    /// [`mem_dbg`](MemDbg::mem_dbg), but expanding only up to `max_depth`\n    /// levels of nested structures.\n    fn mem_dbg_depth(\u0026self, max_depth: usize, flags: DbgFlags) -\u003e core::fmt::Result {\n        self._mem_dbg_depth(\n            \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags()),\n            max_depth,\n            core::mem::size_of_val(self),\n            flags,\n        )\n    }\n\n    /// Writes to a [`core::fmt::Write`] debug infos about the structure memory\n    /// usage as [`mem_dbg_on`](MemDbg::mem_dbg_on), but expanding only up to\n    /// `max_depth` levels of nested structures.\n    fn mem_dbg_depth_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        max_depth: usize,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        self._mem_dbg_depth_on(\n            writer,\n            \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags()),\n            max_depth,\n            \u0026mut String::new(),\n            None,\n            false,\n            core::mem::size_of_val(self),\n            flags,\n        )\n    }\n}\n\n/// Implemens [`MemDbg`] for all types that implement [`MemDbgImpl`].\n///\n/// This is done so that no one can change the implementation of [`MemDbg`],\n/// which ensures consistency in printing.\nimpl\u003cT: MemDbgImpl\u003e MemDbg for T {}\n\n/// Inner trait used to implement [`MemDbg`].\n///\n/// This trait should not be implemented by users, which should use the\n/// [`MemDbg`](mem_dbg_derive::MemDbg) derive macro instead.\n///\n/// The default no-op implementation is used by all types in which it does not\n/// make sense, or it is impossible, to recurse.\npub trait MemDbgImpl: MemSize {\n    #[inline(always)]\n    fn _mem_dbg_rec_on(\n        \u0026self,\n        _writer: \u0026mut impl core::fmt::Write,\n        _total_size: usize,\n        _max_depth: usize,\n        _prefix: \u0026mut String,\n        _is_last: bool,\n        _flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        Ok(())\n    }\n\n    #[cfg(feature = \"std\")]\n    #[doc(hidden)]\n    #[inline(always)]\n    fn _mem_dbg_depth(\n        \u0026self,\n        total_size: usize,\n        max_depth: usize,\n        padded_size: usize,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        struct Wrapper(std::io::Stderr);\n        impl core::fmt::Write for Wrapper {\n            #[inline(always)]\n            fn write_str(\u0026mut self, s: \u0026str) -\u003e core::fmt::Result {\n                use std::io::Write;\n                self.0\n                    .lock()\n                    .write(s.as_bytes())\n                    .map_err(|_| core::fmt::Error)\n                    .map(|_| ())\n            }\n        }\n        self._mem_dbg_depth_on(\n            \u0026mut Wrapper(std::io::stderr()),\n            total_size,\n            max_depth,\n            \u0026mut String::new(),\n            Some(\"\"),\n            true,\n            padded_size,\n            flags,\n        )\n    }\n\n    #[inline(always)]\n    #[allow(clippy::too_many_arguments)]\n    fn _mem_dbg_depth_on(\n        \u0026self,\n        writer: \u0026mut impl core::fmt::Write,\n        total_size: usize,\n        max_depth: usize,\n        prefix: \u0026mut String,\n        field_name: Option\u003c\u0026str\u003e,\n        is_last: bool,\n        padded_size: usize,\n        flags: DbgFlags,\n    ) -\u003e core::fmt::Result {\n        if prefix.len() \u003e max_depth {\n            return Ok(());\n        }\n        let real_size = \u003cSelf as MemSize\u003e::mem_size(self, flags.to_size_flags());\n        if flags.contains(DbgFlags::COLOR) {\n            let color = utils::color(real_size);\n            writer.write_fmt(format_args!(\"{color}\"))?;\n        };\n        if flags.contains(DbgFlags::HUMANIZE) {\n            let (value, uom) = crate::utils::humanize_float(real_size as f64);\n            if uom == \" B\" {\n                writer.write_fmt(format_args!(\"{:\u003e5}  B \", real_size))?;\n            } else {\n                let mut precision = 4;\n                let a = if value \u003c 0.0 { -value } else { value };\n                if a \u003e= 100.0 {\n                    precision = 1;\n                } else if a \u003e= 10.0 {\n                    precision = 2;\n                } else if a \u003e= 1.0 {\n                    precision = 3;\n                }\n                writer.write_fmt(format_args!(\"{0:\u003e4.1$} {2} \", value, precision, uom))?;\n            }\n        } else if flags.contains(DbgFlags::SEPARATOR) {\n            let mut align = crate::utils::n_of_digits(total_size);\n            let mut real_size = real_size;\n            align += align / 3;\n            let mut digits = crate::utils::n_of_digits(real_size);\n            let digit_align = digits + digits / 3;\n            for _ in digit_align..align {\n                writer.write_char(' ')?;\n            }\n\n            let first_digits = digits % 3;\n            let mut multiplier = 10_usize.pow((digits - first_digits) as u32);\n            if first_digits != 0 {\n                writer.write_fmt(format_args!(\"{}\", real_size / multiplier))?;\n            } else {\n                multiplier /= 1000;\n                digits -= 3;\n                writer.write_fmt(format_args!(\" {}\", real_size / multiplier))?;\n            }\n\n            while digits \u003e= 3 {\n                real_size %= multiplier;\n                multiplier /= 1000;\n                writer.write_fmt(format_args!(\"_{:03}\", real_size / multiplier))?;\n                digits -= 3;\n            }\n\n            writer.write_str(\" B \")?;\n        } else {\n            let align = crate::utils::n_of_digits(total_size);\n            writer.write_fmt(format_args!(\"{:\u003ealign$} B \", real_size, align = align))?;\n        }\n\n        if flags.contains(DbgFlags::PERCENTAGE) {\n            writer.write_fmt(format_args!(\n                \"{:\u003e6.2}% \",\n                if total_size == 0 {\n                    100.0\n                } else {\n                    100.0 * real_size as f64 / total_size as f64\n                }\n            ))?;\n        }\n        if flags.contains(DbgFlags::COLOR) {\n            let reset_color = utils::reset_color();\n            writer.write_fmt(format_args!(\"{reset_color}\"))?;\n        };\n        if !prefix.is_empty() {\n            writer.write_str(\u0026prefix[2..])?;\n            if is_last {\n                writer.write_char('')?;\n            } else {\n                writer.write_char('')?;\n            }\n            writer.write_char('')?;\n        }\n\n        if let Some(field_name) = field_name {\n            writer.write_fmt(format_args!(\"{:}\", field_name))?;\n        }\n\n        if flags.contains(DbgFlags::TYPE_NAME) {\n            if flags.contains(DbgFlags::COLOR) {\n                writer.write_fmt(format_args!(\"{}\", utils::type_color()))?;\n            }\n            writer.write_fmt(format_args!(\": {:}\", core::any::type_name::\u003cSelf\u003e()))?;\n            if flags.contains(DbgFlags::COLOR) {\n                writer.write_fmt(format_args!(\"{}\", utils::reset_color()))?;\n            }\n        }\n\n        //dbg!(padded_size, core::mem::size_of_val(self));\n        let padding = padded_size - core::mem::size_of_val(self);\n\n        if padding != 0 {\n            writer.write_fmt(format_args!(\" [{}B]\", padding))?;\n        }\n\n        writer.write_char('\\n')?;\n\n        if is_last {\n            prefix.push_str(\"  \");\n        } else {\n            prefix.push_str(\" \");\n        }\n\n        self._mem_dbg_rec_on(writer, total_size, max_depth, prefix, is_last, flags)?;\n\n        prefix.pop();\n        prefix.pop();\n\n        Ok(())\n    }\n}\n","traces":[{"line":111,"address":[],"length":0,"stats":{"Line":180}},{"line":112,"address":[],"length":0,"stats":{"Line":180}},{"line":153,"address":[],"length":0,"stats":{"Line":402}},{"line":154,"address":[],"length":0,"stats":{"Line":804}},{"line":155,"address":[],"length":0,"stats":{"Line":804}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":984}},{"line":159,"address":[],"length":0,"stats":{"Line":180}},{"line":161,"address":[],"length":0,"stats":{"Line":402}},{"line":169,"address":[],"length":0,"stats":{"Line":13}},{"line":170,"address":[],"length":0,"stats":{"Line":13}},{"line":185,"address":[],"length":0,"stats":{"Line":14}},{"line":187,"address":[],"length":0,"stats":{"Line":28}},{"line":188,"address":[],"length":0,"stats":{"Line":56}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":28}},{"line":191,"address":[],"length":0,"stats":{"Line":14}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":288}},{"line":271,"address":[],"length":0,"stats":{"Line":288}},{"line":277,"address":[],"length":0,"stats":{"Line":14}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":527}},{"line":289,"address":[],"length":0,"stats":{"Line":527}},{"line":291,"address":[],"length":0,"stats":{"Line":1054}},{"line":292,"address":[],"length":0,"stats":{"Line":527}},{"line":293,"address":[],"length":0,"stats":{"Line":527}},{"line":296,"address":[],"length":0,"stats":{"Line":28}},{"line":297,"address":[],"length":0,"stats":{"Line":14}},{"line":298,"address":[],"length":0,"stats":{"Line":14}},{"line":299,"address":[],"length":0,"stats":{"Line":14}},{"line":300,"address":[],"length":0,"stats":{"Line":14}},{"line":301,"address":[],"length":0,"stats":{"Line":14}},{"line":303,"address":[],"length":0,"stats":{"Line":14}},{"line":304,"address":[],"length":0,"stats":{"Line":14}},{"line":310,"address":[],"length":0,"stats":{"Line":352}},{"line":321,"address":[],"length":0,"stats":{"Line":704}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":1760}},{"line":325,"address":[],"length":0,"stats":{"Line":704}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":704}},{"line":330,"address":[],"length":0,"stats":{"Line":480}},{"line":331,"address":[],"length":0,"stats":{"Line":160}},{"line":332,"address":[],"length":0,"stats":{"Line":474}},{"line":334,"address":[],"length":0,"stats":{"Line":4}},{"line":335,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":6}},{"line":345,"address":[],"length":0,"stats":{"Line":384}},{"line":346,"address":[],"length":0,"stats":{"Line":576}},{"line":347,"address":[],"length":0,"stats":{"Line":384}},{"line":348,"address":[],"length":0,"stats":{"Line":192}},{"line":349,"address":[],"length":0,"stats":{"Line":576}},{"line":350,"address":[],"length":0,"stats":{"Line":384}},{"line":351,"address":[],"length":0,"stats":{"Line":192}},{"line":352,"address":[],"length":0,"stats":{"Line":1224}},{"line":355,"address":[],"length":0,"stats":{"Line":384}},{"line":356,"address":[],"length":0,"stats":{"Line":576}},{"line":357,"address":[],"length":0,"stats":{"Line":192}},{"line":358,"address":[],"length":0,"stats":{"Line":732}},{"line":360,"address":[],"length":0,"stats":{"Line":9}},{"line":361,"address":[],"length":0,"stats":{"Line":9}},{"line":362,"address":[],"length":0,"stats":{"Line":36}},{"line":365,"address":[],"length":0,"stats":{"Line":195}},{"line":366,"address":[],"length":0,"stats":{"Line":3}},{"line":367,"address":[],"length":0,"stats":{"Line":3}},{"line":368,"address":[],"length":0,"stats":{"Line":12}},{"line":369,"address":[],"length":0,"stats":{"Line":3}},{"line":372,"address":[],"length":0,"stats":{"Line":576}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":704}},{"line":379,"address":[],"length":0,"stats":{"Line":1056}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":352}},{"line":382,"address":[],"length":0,"stats":{"Line":3}},{"line":384,"address":[],"length":0,"stats":{"Line":349}},{"line":388,"address":[],"length":0,"stats":{"Line":704}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":352}},{"line":393,"address":[],"length":0,"stats":{"Line":1014}},{"line":394,"address":[],"length":0,"stats":{"Line":338}},{"line":395,"address":[],"length":0,"stats":{"Line":22}},{"line":397,"address":[],"length":0,"stats":{"Line":654}},{"line":399,"address":[],"length":0,"stats":{"Line":676}},{"line":402,"address":[],"length":0,"stats":{"Line":704}},{"line":403,"address":[],"length":0,"stats":{"Line":1056}},{"line":406,"address":[],"length":0,"stats":{"Line":704}},{"line":407,"address":[],"length":0,"stats":{"Line":704}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":1408}},{"line":411,"address":[],"length":0,"stats":{"Line":704}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":1056}},{"line":419,"address":[],"length":0,"stats":{"Line":352}},{"line":420,"address":[],"length":0,"stats":{"Line":15}},{"line":423,"address":[],"length":0,"stats":{"Line":704}},{"line":425,"address":[],"length":0,"stats":{"Line":377}},{"line":426,"address":[],"length":0,"stats":{"Line":50}},{"line":428,"address":[],"length":0,"stats":{"Line":654}},{"line":431,"address":[],"length":0,"stats":{"Line":2816}},{"line":433,"address":[],"length":0,"stats":{"Line":704}},{"line":434,"address":[],"length":0,"stats":{"Line":704}},{"line":436,"address":[],"length":0,"stats":{"Line":352}}],"covered":95,"coverable":135},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","src","utils.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n/// Given a float, returns it in a human readable format using SI suffixes.\npub fn humanize_float(mut x: f64) -\u003e (f64, \u0026'static str) {\n    const UOM: \u0026[\u0026str] = \u0026[\n        \"qB\", \"rB\", \"yB\", \"zB\", \"aB\", \"fB\", \"pB\", \"nB\", \"B\", \"mB\", \" B\", \"kB\", \"MB\", \"GB\", \"TB\",\n        \"PB\", \"EB\", \"ZB\", \"YB\", \"RB\", \"QB\",\n    ];\n    let mut uom_idx = 10;\n    debug_assert_eq!(UOM[uom_idx], \" B\");\n\n    if x == 0.0 {\n        return (0.0, UOM[uom_idx]);\n    }\n\n    let abs_x = if x \u003c 0.0 { -x } else { x };\n\n    if abs_x \u003e 1.0 {\n        while abs_x \u003e 1000.0 \u0026\u0026 uom_idx \u003c UOM.len() - 1 {\n            uom_idx += 1;\n            x /= 1000.0;\n        }\n    } else {\n        while abs_x \u003c 0.001 \u0026\u0026 uom_idx \u003e 0 {\n            uom_idx -= 1;\n            x *= 1000.0;\n        }\n    }\n\n    (x, UOM[uom_idx])\n}\n\npub fn color(x: usize) -\u003e \u0026'static str {\n    const KB: usize = 1024;\n    const MB: usize = KB * KB;\n    const GB: usize = MB * KB;\n    #[allow(clippy::match_overlapping_arm)]\n    match x {\n        // white\n        ..KB =\u003e reset_color(),\n        // green\n        ..MB =\u003e \"\\x1B[32m\",\n        // yellow\n        ..GB =\u003e \"\\x1B[33m\",\n        // red\n        _ =\u003e \"\\x1B[31m\",\n    }\n}\n\npub fn type_color() -\u003e \u0026'static str {\n    // custom grey\n    \"\\x1B[38;2;128;128;128m\"\n}\n\npub fn reset_color() -\u003e \u0026'static str {\n    \"\\x1B[0m\"\n}\n\n/// Returns the number of digits of a number.\n///\n/// ```\n/// use mem_dbg::n_of_digits;\n///\n/// assert_eq!(n_of_digits(0), 1);\n/// assert_eq!(n_of_digits(1), 1);\n/// assert_eq!(n_of_digits(10), 2);\n/// assert_eq!(n_of_digits(100), 3);\n/// assert_eq!(n_of_digits(1000), 4);\n/// assert_eq!(n_of_digits(10000), 5);\n/// assert_eq!(n_of_digits(100000), 6);\n/// ```\npub fn n_of_digits(x: usize) -\u003e usize {\n    if x == 0 {\n        return 1;\n    }\n    let mut digits = 0;\n    let mut x = x;\n    while x \u003e 0 {\n        digits += 1;\n        x /= 10;\n    }\n    digits\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":178}},{"line":14,"address":[],"length":0,"stats":{"Line":356}},{"line":15,"address":[],"length":0,"stats":{"Line":356}},{"line":17,"address":[],"length":0,"stats":{"Line":178}},{"line":18,"address":[],"length":0,"stats":{"Line":8}},{"line":21,"address":[],"length":0,"stats":{"Line":510}},{"line":23,"address":[],"length":0,"stats":{"Line":170}},{"line":24,"address":[],"length":0,"stats":{"Line":236}},{"line":25,"address":[],"length":0,"stats":{"Line":20}},{"line":26,"address":[],"length":0,"stats":{"Line":20}},{"line":29,"address":[],"length":0,"stats":{"Line":18}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":340}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":420}},{"line":78,"address":[],"length":0,"stats":{"Line":420}},{"line":79,"address":[],"length":0,"stats":{"Line":14}},{"line":81,"address":[],"length":0,"stats":{"Line":812}},{"line":82,"address":[],"length":0,"stats":{"Line":812}},{"line":83,"address":[],"length":0,"stats":{"Line":2596}},{"line":84,"address":[],"length":0,"stats":{"Line":1095}},{"line":85,"address":[],"length":0,"stats":{"Line":1095}},{"line":87,"address":[],"length":0,"stats":{"Line":406}}],"covered":21,"coverable":33},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_comprehensive_mem_dbg.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2025 Inria\n * SPDX-FileCopyrightText: 2025 Tommaso Fontana\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n//! Comprehensive test for MemDbg that includes all types in the crate\n//! that implement the necessary traits.\n\n#![cfg(feature = \"std\")]\n#![cfg(feature = \"derive\")]\n\nuse mem_dbg::*;\nuse std::collections::{HashMap, HashSet};\nuse std::collections::hash_map::{RandomState, DefaultHasher};\nuse std::hash::BuildHasherDefault;\nuse std::sync::{Arc, Mutex, RwLock};\nuse core::sync::atomic::*;\nuse core::num::*;\nuse core::marker::{PhantomData, PhantomPinned};\nuse core::cell::{Cell, RefCell, UnsafeCell, OnceCell};\nuse core::ops::*;\nuse core::ptr::NonNull;\nuse core::alloc::Layout;\nuse std::path::PathBuf;\nuse std::ffi::OsString;\nuse std::io::{BufReader, BufWriter, Cursor};\nuse std::fs::File;\n\n// Static data for references\nstatic STATIC_STR: \u0026str = \"static string\";\n\n#[derive(MemSize, MemDbg)]\nstruct ComprehensiveStruct {\n    // Primitive types\n    unit: (),\n    boolean: bool,\n    character: char,\n    float32: f32,\n    float64: f64,\n    \n    // Unsigned integers\n    u8_val: u8,\n    u16_val: u16,\n    u32_val: u32,\n    u64_val: u64,\n    u128_val: u128,\n    usize_val: usize,\n    \n    // Signed integers\n    i8_val: i8,\n    i16_val: i16,\n    i32_val: i32,\n    i64_val: i64,\n    i128_val: i128,\n    isize_val: isize,\n    \n    // Atomic types\n    atomic_bool: AtomicBool,\n    atomic_i8: AtomicI8,\n    atomic_i16: AtomicI16,\n    atomic_i32: AtomicI32,\n    atomic_i64: AtomicI64,\n    atomic_isize: AtomicIsize,\n    atomic_u8: AtomicU8,\n    atomic_u16: AtomicU16,\n    atomic_u32: AtomicU32,\n    atomic_u64: AtomicU64,\n    atomic_usize: AtomicUsize,\n    \n    // NonZero types\n    nonzero_i8: NonZeroI8,\n    nonzero_i16: NonZeroI16,\n    nonzero_i32: NonZeroI32,\n    nonzero_i64: NonZeroI64,\n    nonzero_i128: NonZeroI128,\n    nonzero_isize: NonZeroIsize,\n    nonzero_u8: NonZeroU8,\n    nonzero_u16: NonZeroU16,\n    nonzero_u32: NonZeroU32,\n    nonzero_u64: NonZeroU64,\n    nonzero_u128: NonZeroU128,\n    nonzero_usize: NonZeroUsize,\n    \n    // Phantom types\n    phantom_pinned: PhantomPinned,\n    phantom_data: PhantomData\u003ci32\u003e,\n    \n    // String types\n    string: String,\n    \n    // Option\n    option_some: Option\u003ci32\u003e,\n    option_none: Option\u003ci32\u003e,\n    \n    // Box\n    boxed: Box\u003cu64\u003e,\n    \n    // Arc\n    arc: Arc\u003ci32\u003e,\n    \n    // Vec and arrays\n    vec_values: Vec\u003ci32\u003e,\n    array: [u8; 10],\n    \n    // Tuples\n    tuple2: (i32, String),\n    tuple3: (i32, String, f64),\n    tuple4: (i32, String, f64, bool),\n    \n    // Hash collections\n    hash_set: HashSet\u003ci32\u003e,\n    hash_map: HashMap\u003cString, i32\u003e,\n    \n    // Ranges\n    range: Range\u003cusize\u003e,\n    range_from: RangeFrom\u003cusize\u003e,\n    range_inclusive: RangeInclusive\u003cusize\u003e,\n    range_to: RangeTo\u003cusize\u003e,\n    range_to_inclusive: RangeToInclusive\u003cusize\u003e,\n    \n    // Cells\n    ref_cell: RefCell\u003ci32\u003e,\n    cell: Cell\u003ci32\u003e,\n    unsafe_cell: UnsafeCell\u003ci32\u003e,\n    once_cell: OnceCell\u003cString\u003e,\n    \n    // Synchronization primitives\n    mutex: Mutex\u003ci32\u003e,\n    rw_lock: RwLock\u003cString\u003e,\n    \n    // Path types\n    path_buf: PathBuf,\n    os_string: OsString,\n    \n    // References\n    reference: \u0026'static str,\n    mut_reference: \u0026'static mut i32,\n    \n    // Function pointers\n    fn_ptr0: fn() -\u003e i32,\n    fn_ptr1: fn(i32) -\u003e i32,\n    fn_ptr2: fn(i32, i32) -\u003e i32,\n    \n    // Hash builders\n    build_hasher: BuildHasherDefault\u003cDefaultHasher\u003e,\n    random_state: RandomState,\n    \n    // Layout\n    layout: Layout,\n    \n    // NonNull pointer\n    non_null: NonNull\u003ci32\u003e,\n    \n    // I/O wrappers\n    buf_reader: BufReader\u003cFile\u003e,\n    buf_writer: BufWriter\u003cFile\u003e,\n    cursor: Cursor\u003cVec\u003cu8\u003e\u003e,\n}\n\n#[test]\nfn test_comprehensive_mem_dbg() {\n    // Create leaked references for the test\n    let leaked_mut: \u0026'static mut i32 = Box::leak(Box::new(999));\n    let leaked_for_nonnull: \u0026'static mut i32 = Box::leak(Box::new(888));\n    \n    let mut hash_set = HashSet::new();\n    hash_set.insert(1);\n    hash_set.insert(2);\n    hash_set.insert(3);\n    \n    let mut hash_map = HashMap::new();\n    hash_map.insert(\"key1\".to_string(), 100);\n    hash_map.insert(\"key2\".to_string(), 200);\n    \n    let once_cell = OnceCell::new();\n    once_cell.set(\"initialized\".to_string()).unwrap();\n    \n    let comprehensive = ComprehensiveStruct {\n        // Primitives\n        unit: (),\n        boolean: true,\n        character: 'A',\n        float32: 3.14,\n        float64: 2.718,\n        \n        // Unsigned integers\n        u8_val: 8,\n        u16_val: 16,\n        u32_val: 32,\n        u64_val: 64,\n        u128_val: 128,\n        usize_val: 1024,\n        \n        // Signed integers\n        i8_val: -8,\n        i16_val: -16,\n        i32_val: -32,\n        i64_val: -64,\n        i128_val: -128,\n        isize_val: -1024,\n        \n        // Atomics\n        atomic_bool: AtomicBool::new(true),\n        atomic_i8: AtomicI8::new(8),\n        atomic_i16: AtomicI16::new(16),\n        atomic_i32: AtomicI32::new(32),\n        atomic_i64: AtomicI64::new(64),\n        atomic_isize: AtomicIsize::new(1024),\n        atomic_u8: AtomicU8::new(8),\n        atomic_u16: AtomicU16::new(16),\n        atomic_u32: AtomicU32::new(32),\n        atomic_u64: AtomicU64::new(64),\n        atomic_usize: AtomicUsize::new(1024),\n        \n        // NonZero types\n        nonzero_i8: NonZeroI8::new(1).unwrap(),\n        nonzero_i16: NonZeroI16::new(1).unwrap(),\n        nonzero_i32: NonZeroI32::new(1).unwrap(),\n        nonzero_i64: NonZeroI64::new(1).unwrap(),\n        nonzero_i128: NonZeroI128::new(1).unwrap(),\n        nonzero_isize: NonZeroIsize::new(1).unwrap(),\n        nonzero_u8: NonZeroU8::new(1).unwrap(),\n        nonzero_u16: NonZeroU16::new(1).unwrap(),\n        nonzero_u32: NonZeroU32::new(1).unwrap(),\n        nonzero_u64: NonZeroU64::new(1).unwrap(),\n        nonzero_u128: NonZeroU128::new(1).unwrap(),\n        nonzero_usize: NonZeroUsize::new(1).unwrap(),\n        \n        // Phantoms\n        phantom_pinned: PhantomPinned,\n        phantom_data: PhantomData,\n        \n        // Strings\n        string: \"Hello, world!\".to_string(),\n        \n        // Option\n        option_some: Some(42),\n        option_none: None,\n        \n        // Box\n        boxed: Box::new(12345),\n        \n        // Arc\n        arc: Arc::new(42),\n        \n        // Vec and arrays\n        vec_values: vec![1, 2, 3, 4, 5],\n        array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        \n        // Tuples\n        tuple2: (42, \"answer\".to_string()),\n        tuple3: (1, \"two\".to_string(), 3.0),\n        tuple4: (1, \"two\".to_string(), 3.0, true),\n        \n        // Hash collections\n        hash_set,\n        hash_map,\n        \n        // Ranges\n        range: 0..10,\n        range_from: 5..,\n        range_inclusive: 0..=10,\n        range_to: ..10,\n        range_to_inclusive: ..=10,\n        \n        // Cells\n        ref_cell: RefCell::new(100),\n        cell: Cell::new(200),\n        unsafe_cell: UnsafeCell::new(300),\n        once_cell,\n        \n        // Sync primitives\n        mutex: Mutex::new(400),\n        rw_lock: RwLock::new(\"locked string\".to_string()),\n        \n        // Paths\n        path_buf: PathBuf::from(\"/tmp/test\"),\n        os_string: OsString::from(\"os string\"),\n        \n        // References\n        reference: STATIC_STR,\n        mut_reference: leaked_mut,\n        \n        // Function pointers\n        fn_ptr0: || 42,\n        fn_ptr1: |x| x + 1,\n        fn_ptr2: |x, y| x + y,\n        \n        // Hash builders\n        build_hasher: BuildHasherDefault::\u003cDefaultHasher\u003e::default(),\n        random_state: RandomState::new(),\n        \n        // Layout\n        layout: Layout::from_size_align(128, 8).unwrap(),\n        \n        // NonNull\n        non_null: NonNull::from(leaked_for_nonnull),\n        \n        // I/O wrappers\n        buf_reader: BufReader::new(File::open(\"/dev/null\").unwrap()),\n        buf_writer: BufWriter::new(File::create(\"/tmp/test_comprehensive_buf_writer\").unwrap()),\n        cursor: Cursor::new(vec![1, 2, 3, 4]),\n    };\n    \n    // Test that mem_size works\n    let size = comprehensive.mem_size(SizeFlags::default());\n    assert!(size \u003e 0, \"Size should be greater than 0\");\n    \n    let size_with_capacity = comprehensive.mem_size(SizeFlags::CAPACITY);\n    assert!(size_with_capacity \u003e= size, \"Size with capacity should be \u003e= default size\");\n    \n    // Test that mem_dbg works without errors\n    let result = comprehensive.mem_dbg(DbgFlags::default());\n    assert!(result.is_ok(), \"mem_dbg should succeed: {:?}\", result);\n    \n    // Test with different flags\n    let result = comprehensive.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY);\n    assert!(result.is_ok(), \"mem_dbg with CAPACITY should succeed\");\n    \n    let result = comprehensive.mem_dbg(DbgFlags::default() | DbgFlags::HUMANIZE);\n    assert!(result.is_ok(), \"mem_dbg with HUMANIZE should succeed\");\n    \n    let result = comprehensive.mem_dbg(DbgFlags::default() | DbgFlags::CAPACITY | DbgFlags::HUMANIZE);\n    assert!(result.is_ok(), \"mem_dbg with CAPACITY and HUMANIZE should succeed\");\n}\n\n// Test optional features\n#[cfg(feature = \"rand\")]\n#[test]\nfn test_rand_types() {\n    use rand::rngs::{SmallRng, StdRng};\n    use rand::SeedableRng;\n    \n    #[derive(MemSize, MemDbg)]\n    struct RandStruct {\n        small_rng: SmallRng,\n        std_rng: StdRng,\n    }\n    \n    let s = RandStruct {\n        small_rng: SmallRng::seed_from_u64(42),\n        std_rng: StdRng::seed_from_u64(42),\n    };\n    \n    let size = s.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    assert!(s.mem_dbg(DbgFlags::default()).is_ok());\n}\n\n#[cfg(feature = \"half\")]\n#[test]\nfn test_half_types() {\n    use half::{f16, bf16};\n    \n    #[derive(MemSize, MemDbg)]\n    struct HalfStruct {\n        f16_val: f16,\n        bf16_val: bf16,\n    }\n    \n    let s = HalfStruct {\n        f16_val: f16::from_f32(3.14),\n        bf16_val: bf16::from_f32(2.718),\n    };\n    \n    let size = s.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    assert!(s.mem_dbg(DbgFlags::default()).is_ok());\n}\n\n#[cfg(feature = \"maligned\")]\n#[test]\nfn test_maligned_types() {\n    use maligned::{A2, A4, A8, A16, A32, A64, A128, A256, A512, Aligned};\n    \n    #[derive(MemSize, MemDbg)]\n    struct MalignedStruct {\n        a2: A2,\n        a4: A4,\n        a8: A8,\n        a16: A16,\n        a32: A32,\n        a64: A64,\n        a128: A128,\n        a256: A256,\n        a512: A512,\n        aligned_u32: Aligned\u003cA16, u32\u003e,\n        aligned_vec: Aligned\u003cA64, Vec\u003ci32\u003e\u003e,\n    }\n    \n    let s = MalignedStruct {\n        a2: A2::default(),\n        a4: A4::default(),\n        a8: A8::default(),\n        a16: A16::default(),\n        a32: A32::default(),\n        a64: A64::default(),\n        a128: A128::default(),\n        a256: A256::default(),\n        a512: A512::default(),\n        aligned_u32: Aligned::new(42),\n        aligned_vec: Aligned::new(vec![1, 2, 3]),\n    };\n    \n    let size = s.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    assert!(s.mem_dbg(DbgFlags::default()).is_ok());\n}\n\n#[cfg(feature = \"mmap-rs\")]\n#[test]\nfn test_mmap_types() {\n    use mmap_rs::{Mmap, MmapMut, MmapOptions};\n    use std::fs::OpenOptions;\n    \n    #[derive(MemSize, MemDbg)]\n    struct MmapStruct {\n        mmap: Mmap,\n        mmap_mut: MmapMut,\n    }\n    \n    // Create a temp file for mmap\n    let file = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .create(true)\n        .open(\"/tmp/test_mmap_comprehensive\")\n        .unwrap();\n    file.set_len(1024).unwrap();\n    \n    let s = MmapStruct {\n        mmap: unsafe { MmapOptions::new(1024).unwrap().with_file(\u0026file, 0).map().unwrap() },\n        mmap_mut: unsafe { MmapOptions::new(1024).unwrap().with_file(\u0026file, 0).map_mut().unwrap() },\n    };\n    \n    let size = s.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    assert!(s.mem_dbg(DbgFlags::default()).is_ok());\n}\n\n#[test]\nfn test_comprehensive_nested() {\n    #[derive(MemSize, MemDbg)]\n    struct Nested {\n        vec_of_vecs: Vec\u003cVec\u003cString\u003e\u003e,\n        option_box: Option\u003cBox\u003ci32\u003e\u003e,\n        arc_mutex: Arc\u003cMutex\u003cVec\u003ci32\u003e\u003e\u003e,\n    }\n    \n    let nested = Nested {\n        vec_of_vecs: vec![\n            vec![\"a\".to_string(), \"b\".to_string()],\n            vec![\"c\".to_string()],\n        ],\n        option_box: Some(Box::new(999)),\n        arc_mutex: Arc::new(Mutex::new(vec![1, 2, 3])),\n    };\n    \n    let size = nested.mem_size(SizeFlags::default());\n    assert!(size \u003e 0);\n    \n    let result = nested.mem_dbg(DbgFlags::default());\n    assert!(result.is_ok(), \"Nested structure mem_dbg should succeed\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_mem_size.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n#![cfg(feature = \"derive\")]\n#![cfg_attr(feature = \"offset_of_enum\", feature(offset_of_enum))]\n\nuse core::marker::PhantomData;\nuse core::mem::size_of;\nuse mem_dbg::*;\nuse std::sync::atomic::AtomicU64;\n\n#[derive(MemSize)]\n#[cfg_attr(feature = \"std\", derive(MemDbg))]\nunion SingletonUnion\u003cA: Copy\u003e {\n    a: A,\n}\n\n#[allow(dead_code)]\n#[derive(MemSize)]\n#[cfg_attr(feature = \"std\", derive(MemDbg))]\nenum TestEnum {\n    Unit,\n    Unit2(),\n    Unit3 {},\n    Union(SingletonUnion\u003cu8\u003e),\n    Unnamed(usize, u8),\n    Named {\n        first: usize,\n        second: PhantomData\u003cu8\u003e,\n    },\n}\n\n#[test]\nfn test_vec_capacity() {\n    let mut v = vec![Vec::with_capacity(10)];\n    v[0].push(1);\n    v[0].push(2);\n    // We consider the capacity of the inner vector\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY) - v.mem_size(SizeFlags::default()),\n        8 * std::mem::size_of::\u003ci32\u003e()\n    );\n}\n\n#[test]\nfn test_vec_copy_or_not() {\n    #[derive(Clone, MemSize)]\n    #[cfg_attr(feature = \"std\", derive(MemDbg))]\n    struct NewType(usize);\n\n    assert_eq!(\n        vec![NewType(1_usize); 10].mem_size(SizeFlags::default()),\n        vec![1_usize; 10].mem_size(SizeFlags::default())\n    );\n}\n\n#[test]\nfn test_boxed_slice_copy_or_not() {\n    #[derive(Clone, MemSize)]\n    #[cfg_attr(feature = \"std\", derive(MemDbg))]\n    struct NewType(usize);\n\n    assert_eq!(\n        vec![NewType(1_usize); 10]\n            .into_boxed_slice()\n            .mem_size(SizeFlags::FOLLOW_REFS),\n        vec![1_usize; 10]\n            .into_boxed_slice()\n            .mem_size(SizeFlags::FOLLOW_REFS)\n    );\n}\n\n#[test]\nfn test_slice_copy_or_not() {\n    #[derive(Clone, MemSize)]\n    #[cfg_attr(feature = \"std\", derive(MemDbg))]\n    struct NewType(usize);\n\n    assert_eq!(\n        vec![NewType(1_usize); 10]\n            .into_boxed_slice()\n            .as_ref()\n            .mem_size(SizeFlags::FOLLOW_REFS),\n        vec![1_usize; 10]\n            .into_boxed_slice()\n            .as_ref()\n            .mem_size(SizeFlags::FOLLOW_REFS)\n    );\n}\n\n#[test]\nfn test_array_copy_or_not() {\n    #[derive(Clone, Copy, MemSize)]\n    #[cfg_attr(feature = \"std\", derive(MemDbg))]\n    struct NewType(usize);\n\n    assert_eq!(\n        [NewType(1_usize); 10]\n            .as_ref()\n            .mem_size(SizeFlags::FOLLOW_REFS),\n        [1_usize; 10].as_ref().mem_size(SizeFlags::FOLLOW_REFS)\n    );\n}\n\n#[test]\nfn test_empty_struct() {\n    #[derive(MemSize, Clone, Copy)]\n    #[copy_type]\n    struct Data {}\n    let v = Data {};\n    assert_eq!(v.mem_size(SizeFlags::default()), 0);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), 0);\n}\n\n#[test]\nfn test_struct() {\n    #[derive(MemSize)]\n    struct Data {\n        a: u64,\n        b: Vec\u003cusize\u003e,\n    }\n    let mut v = Data {\n        a: 10,\n        b: Vec::with_capacity(10),\n    };\n    v.b.push(1);\n    v.b.push(2);\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        8 + v.b.mem_size(SizeFlags::default())\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        8 + v.b.mem_size(SizeFlags::CAPACITY)\n    );\n}\n\n#[test]\nfn test_empty_tuple_struct() {\n    #[derive(MemSize)]\n    struct Data();\n    let v = Data();\n    assert_eq!(v.mem_size(SizeFlags::default()), 0);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), 0);\n}\n\n#[test]\nfn test_tuple_struct() {\n    #[derive(MemSize)]\n    struct Data(u64, Vec\u003cusize\u003e);\n    let mut v = Data(10, Vec::with_capacity(10));\n    v.1.push(1);\n    v.1.push(2);\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        8 + v.1.mem_size(SizeFlags::default())\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        8 + v.1.mem_size(SizeFlags::CAPACITY),\n    );\n}\n\n#[test]\nfn test_padding() {\n    assert_eq!((0_u8, 0_u64).mem_size(SizeFlags::default()), 16);\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    struct TuplePadded((u8, u64));\n    let v = TuplePadded((0, 0));\n    assert_eq!(v.mem_size(SizeFlags::default()), 16);\n\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    struct StructPadded(u8, u64);\n    let v = StructPadded(0, 0);\n    assert_eq!(v.mem_size(SizeFlags::default()), 16);\n\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    struct StructStructPadded(StructPadded);\n    let v = StructStructPadded(StructPadded(0, 0));\n    assert_eq!(v.mem_size(SizeFlags::default()), 16);\n}\n\n#[test]\nfn test_option() {\n    let v = Some(1_usize);\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        2 * core::mem::size_of::\u003cusize\u003e(),\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        v.mem_size(SizeFlags::default())\n    );\n    let v = Some(Some(1_usize));\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        2 * core::mem::size_of::\u003cusize\u003e(),\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        v.mem_size(SizeFlags::default())\n    );\n    let v = Some(Some(Some(1_usize)));\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        2 * core::mem::size_of::\u003cusize\u003e(),\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        v.mem_size(SizeFlags::default())\n    );\n}\n\n#[test]\nfn test_enum() {\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    #[repr(u8)]\n    enum Data {\n        A,\n        B(u64),\n        C(u64, Vec\u003cusize\u003e),\n    }\n\n    let enum_size = core::mem::size_of::\u003cData\u003e();\n\n    let v = Data::A;\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let v = Data::B(1000);\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let d = vec![1, 2, 3, 4, 5];\n    let len = d.len();\n    let capacity = d.capacity();\n    let v = Data::C(1000, d);\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        enum_size + core::mem::size_of::\u003cusize\u003e() * len\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        enum_size + core::mem::size_of::\u003cusize\u003e() * capacity\n    );\n}\n\n#[test]\n/// \u003chttps://github.com/rust-lang/rfcs/issues/1230\u003e\nfn test_exotic() {\n    // A reference cannot be null, so the compiler should use null as Option's\n    // None variant\n    let v: Option\u003c\u0026u8\u003e = None;\n    assert_eq!(core::mem::size_of::\u003cusize\u003e(), core::mem::size_of::\u003c\u0026u8\u003e());\n    assert_eq!(\n        core::mem::size_of::\u003cusize\u003e(),\n        core::mem::size_of::\u003cOption\u003c\u0026u8\u003e\u003e()\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::default()),\n        core::mem::size_of::\u003cusize\u003e()\n    );\n    assert_eq!(\n        v.mem_size(SizeFlags::CAPACITY),\n        core::mem::size_of::\u003cusize\u003e()\n    );\n\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    enum Data1 {\n        A,\n        B,\n    }\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    enum Data2 {\n        A,\n        B(Data1),\n    }\n\n    // nested enums can be flattened IFF they don't have a repr attribute\n    assert_eq!(core::mem::size_of::\u003cData1\u003e(), core::mem::size_of::\u003cData2\u003e(),);\n\n    let enum_size = core::mem::size_of::\u003cData1\u003e();\n    let v = Data1::A;\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let v = Data1::B;\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n\n    let enum_size = core::mem::size_of::\u003cData2\u003e();\n    let v = Data2::A;\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let v = Data2::B(Data1::A);\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n    let v = Data2::B(Data1::B);\n    assert_eq!(v.mem_size(SizeFlags::default()), enum_size);\n    assert_eq!(v.mem_size(SizeFlags::CAPACITY), enum_size);\n}\n\n#[test]\nfn test_tuple() {\n    assert_eq!((8, 4).mem_size(SizeFlags::default()), 8);\n    assert_eq!((8, 4).mem_size(SizeFlags::CAPACITY), 8);\n}\n\n#[test]\nfn test_atomic() {\n    assert_eq!(AtomicU64::new(0).mem_size(SizeFlags::default()), 8);\n}\n\n#[test]\nfn test_unit() {\n    assert_eq!(().mem_size(SizeFlags::default()), 0);\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_phantom() {\n    struct Dummy();\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    #[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\n    struct Example\u003cA\u003e(PhantomData\u003cA\u003e);\n\n    Example::\u003cDummy\u003e(PhantomData)\n        .mem_dbg(DbgFlags::default())\n        .unwrap();\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_vec_strings() {\n    let data = vec![String::new(), String::new()];\n    data.mem_dbg(DbgFlags::default()).unwrap();\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_array_u8() {\n    let data = [0_u8; 10];\n    assert_eq!(data.mem_size(SizeFlags::default()), 10);\n    data.mem_dbg(DbgFlags::default()).unwrap();\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_array_empty_struct() {\n    #[derive(MemSize, MemDbg, Clone, Copy)]\n    struct Dummy;\n    let data = [Dummy; 10];\n    assert_eq!(data.mem_size(SizeFlags::default()), 0);\n    data.mem_dbg(DbgFlags::default()).unwrap();\n}\n\n#[test]\nfn test_slice_u8() {\n    let data = [0_u8; 10].as_slice();\n    assert_eq!((*data).mem_size(SizeFlags::default()), 10);\n    // Autodereferentiation\n    assert_eq!(data.mem_size(SizeFlags::default()), 10);\n    assert_eq!(\n        \u003c\u0026[u8] as MemSize\u003e::mem_size(\u0026data, SizeFlags::default()),\n        16\n    );\n    assert_eq!(\n        \u003c\u0026[u8] as MemSize\u003e::mem_size(\u0026data, SizeFlags::default() | SizeFlags::FOLLOW_REFS),\n        26\n    );\n}\n\n#[test]\nfn test_slice_empty_struct() {\n    #[derive(MemSize, MemDbg, Clone, Copy)]\n    struct Dummy;\n    let data = [Dummy; 10].as_slice();\n    assert_eq!((*data).mem_size(SizeFlags::default()), 0);\n    // Autodereferentiation\n    assert_eq!(data.mem_size(SizeFlags::default()), 0);\n    assert_eq!(\n        \u003c\u0026[Dummy] as MemSize\u003e::mem_size(\u0026data, SizeFlags::default()),\n        16\n    );\n    assert_eq!(\n        \u003c\u0026[Dummy] as MemSize\u003e::mem_size(\u0026data, SizeFlags::default() | SizeFlags::FOLLOW_REFS),\n        16\n    );\n}\n\n#[test]\n#[cfg(feature = \"std\")]\nfn test_indirect_call() {\n    #[cfg_attr(feature = \"derive\", derive(MemSize))]\n    #[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\n    struct Dummy\u003cT\u003e(Vec\u003cT\u003e);\n\n    fn test\u003cT\u003e(data: Vec\u003cT\u003e)\n    where\n        // this is needed because the type system is not smart enough to infer it\n        Vec\u003cT\u003e: MemSize + MemDbgImpl,\n    {\n        let data = Dummy(data);\n        data.mem_dbg(DbgFlags::default()).unwrap();\n    }\n\n    test(vec![1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn test_vec_slice_i64() {\n    let mut data: Vec\u003ci64\u003e = vec![1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice = data.as_slice();\n    let size_of_non_mutable_slice = core::mem::size_of_val(non_mutable_slice);\n    let non_mutable_slice_shallow_size =\n        \u003c\u0026[i64] as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003c\u0026[i64] as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let mutable_slice = data.as_mut_slice();\n    let size_of_mutable_slice = core::mem::size_of_val(mutable_slice);\n\n    let mutable_slice_shallow_size =\n        \u003c\u0026mut [i64] as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003c\u0026mut [i64] as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n\n    assert_eq!(non_mutable_slice_shallow_size, size_of::\u003c\u0026[i64]\u003e());\n\n    assert_eq!(mutable_slice_shallow_size, size_of::\u003c\u0026mut [i64]\u003e());\n\n    assert_eq!(\n        non_mutable_slice_deep_size,\n        size_of::\u003c\u0026[i64]\u003e() + size_of_non_mutable_slice\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size,\n        size_of::\u003c\u0026mut [i64]\u003e() + size_of_mutable_slice\n    );\n}\n\n#[test]\nfn test_vec_slice_i32() {\n    let mut data: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice = data.as_slice();\n    let size_of_non_mutable_slice = core::mem::size_of_val(non_mutable_slice);\n    let non_mutable_slice_shallow_size =\n        \u003c\u0026[i32] as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003c\u0026[i32] as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let mutable_slice = data.as_mut_slice();\n    let size_of_mutable_slice = core::mem::size_of_val(mutable_slice);\n    let mutable_slice_shallow_size =\n        \u003c\u0026mut [i32] as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003c\u0026mut [i32] as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n\n    assert_eq!(non_mutable_slice_shallow_size, size_of::\u003c\u0026[i64]\u003e());\n\n    assert_eq!(mutable_slice_shallow_size, size_of::\u003c\u0026mut [i64]\u003e());\n\n    assert_eq!(\n        non_mutable_slice_deep_size,\n        size_of::\u003c\u0026[i64]\u003e() + size_of_non_mutable_slice\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size,\n        size_of::\u003c\u0026mut [i64]\u003e() + size_of_mutable_slice\n    );\n}\n\n#[test]\nfn test_array_slice_i64() {\n    let mut data: [i64; 5] = [1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice = data.as_slice();\n    let size_of_non_mutable_slice = core::mem::size_of_val(non_mutable_slice);\n    let non_mutable_slice_shallow_size =\n        \u003c\u0026[i64] as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003c\u0026[i64] as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let mutable_slice = data.as_mut_slice();\n    let size_of_mutable_slice = core::mem::size_of_val(mutable_slice);\n    let mutable_slice_shallow_size =\n        \u003c\u0026mut [i64] as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003c\u0026mut [i64] as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n\n    assert_eq!(\n        non_mutable_slice_deep_size,\n        core::mem::size_of::\u003c\u0026[i64]\u003e() + size_of_non_mutable_slice\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size,\n        core::mem::size_of::\u003c\u0026mut [i64]\u003e() + size_of_mutable_slice\n    );\n}\n\n#[test]\n#[should_panic]\nfn test_array_slice_i64_without_specifications() {\n    let mut data: [i64; 5] = [1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice_shallow_size = data.as_slice().mem_size(SizeFlags::default());\n    let non_mutable_slice_deep_size = data\n        .as_slice()\n        .mem_size(SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n    let mutable_slice_shallow_size = data\n        .as_mut_slice()\n        .mem_size(SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n    let mutable_slice_deep_size = data\n        .as_mut_slice()\n        .mem_size(SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n}\n\n#[test]\nfn test_array_slice_i32() {\n    let mut data: [i32; 5] = [1, 2, 3, 4, 5];\n\n    // A mutable slice should have the same size as a non mutable one\n    let non_mutable_slice = data.as_slice();\n    let size_of_non_mutable_slice = core::mem::size_of_val(non_mutable_slice);\n    let non_mutable_slice_shallow_size =\n        \u003c\u0026[i32] as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003c\u0026[i32] as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let mutable_slice = data.as_mut_slice();\n    let size_of_mutable_slice = core::mem::size_of_val(mutable_slice);\n    let mutable_slice_shallow_size =\n        \u003c\u0026mut [i32] as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003c\u0026mut [i32] as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n\n    assert_eq!(\n        non_mutable_slice_deep_size,\n        core::mem::size_of::\u003c\u0026[i64]\u003e() + size_of_non_mutable_slice\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size,\n        core::mem::size_of::\u003c\u0026mut [i64]\u003e() + size_of_mutable_slice\n    );\n}\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\nstruct MutableSliceWrapper\u003c'a\u003e {\n    data: \u0026'a mut [i64],\n}\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\nstruct NonMutableSliceWrapper\u003c'a\u003e {\n    data: \u0026'a [i64],\n}\n\n#[test]\nfn test_compare_structs() {\n    let mut data: [i64; 5] = [1, 2, 3, 4, 5];\n    let mutable_slice = MutableSliceWrapper {\n        data: data.as_mut_slice(),\n    };\n    let mutable_slice_shallow_size =\n        \u003cMutableSliceWrapper as MemSize\u003e::mem_size(\u0026mutable_slice, SizeFlags::default());\n    let mutable_slice_deep_size = \u003cMutableSliceWrapper as MemSize\u003e::mem_size(\n        \u0026mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n    let non_mutable_slice = NonMutableSliceWrapper {\n        data: data.as_slice(),\n    };\n    let non_mutable_slice_shallow_size =\n        \u003cNonMutableSliceWrapper as MemSize\u003e::mem_size(\u0026non_mutable_slice, SizeFlags::default());\n    let non_mutable_slice_deep_size = \u003cNonMutableSliceWrapper as MemSize\u003e::mem_size(\n        \u0026non_mutable_slice,\n        SizeFlags::default() | SizeFlags::FOLLOW_REFS,\n    );\n\n    assert_eq!(\n        mutable_slice_shallow_size, non_mutable_slice_shallow_size,\n        \"Expected mutable slice shallow size to be identical to non mutable slice shallow size\"\n    );\n\n    assert_eq!(\n        mutable_slice_deep_size, non_mutable_slice_deep_size,\n        \"Expected mutable slice deep size to be identical to non mutable slice deep size\"\n    );\n}\n\n/// Macro to generate test functions given a type T and the expected size.\nmacro_rules! test_size {\n    ($(($object:ty, $shallow_size:expr, $deep_size:expr)),*) =\u003e {\n        $(\n            paste::paste! {\n                #[test]\n                fn [\u003ctest_ $object:lower _size\u003e]() {\n                    // First, we check that the shallow size of the object is the expected one,\n                    // meaning that we are not following any reference\n                    let mut data: $object = Default::default();\n                    let shallow_object_size = \u003c$object as MemSize\u003e::mem_size(\u0026data, SizeFlags::default());\n                    assert_eq!(\n                        shallow_object_size,\n                        $shallow_size,\n                    );\n\n                    // We check that any pointer is always the size of a usize,\n                    // which is the size of a pointer on the current architecture\n                    let reference = \u0026data;\n                    let reference_size = \u003c\u0026'_ $object as MemSize\u003e::mem_size(\u0026reference, SizeFlags::default());\n\n                    assert_eq!(\n                        reference_size,\n                        core::mem::size_of::\u003cusize\u003e()\n                    );\n\n                    // Next, we check that the deep size of the object is the expected one,\n                    // meaning that we are following all references\n                    let deep_object_size = \u003c$object as MemSize\u003e::mem_size(\u0026data, SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n                    assert_eq!(\n                        deep_object_size,\n                        $deep_size\n                    );\n\n                    // We now  check that the deep size of the reference to this object is equal to the size of a pointer\n                    // plus the deep size of the object\n                    let deep_reference_size = \u003c\u0026'_ $object as MemSize\u003e::mem_size(\u0026reference, SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n                    assert_eq!(\n                        deep_reference_size,\n                        core::mem::size_of::\u003cusize\u003e() + deep_object_size\n                    );\n\n                    let mutable_reference = \u0026mut data;\n                    let mutable_reference_size = \u003c\u0026'_ mut $object as MemSize\u003e::mem_size(\u0026mutable_reference, SizeFlags::default());\n                    // We check that the mutable reference has the same size as the reference\n                    assert_eq!(\n                        mutable_reference_size,\n                        core::mem::size_of::\u003cusize\u003e(),\n                    );\n\n                    // We check that the deep size of the mutable reference is the same as the deep size of the reference\n                    // i.e. the size of a pointer plus the deep size of the object\n                    let deep_mutable_reference_size = \u003c\u0026'_ mut $object as MemSize\u003e::mem_size(\u0026mutable_reference, SizeFlags::default() | SizeFlags::FOLLOW_REFS);\n                    assert_eq!(\n                        deep_mutable_reference_size,\n                        deep_reference_size,\n                    );\n                }\n            }\n        )*\n    };\n}\n\n#[derive(MemSize, Default)]\nenum TestEnum2 {\n    #[default]\n    A,\n    _B(u64),\n    _C(u64, Vec\u003cusize\u003e),\n}\n\n#[repr(u8)]\n#[derive(MemSize, Default)]\nenum TestEnumReprU8 {\n    #[default]\n    A,\n    _B(u64),\n    _C(u64, Vec\u003cusize\u003e),\n}\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\n#[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\nunion TestUnion {\n    a: u64,\n}\n\nimpl Default for TestUnion {\n    fn default() -\u003e Self {\n        TestUnion { a: 0 }\n    }\n}\n\ntest_size!(\n    (u8, 1, 1),\n    (u16, 2, 2),\n    (u32, 4, 4),\n    (u64, 8, 8),\n    (u128, 16, 16),\n    (i8, 1, 1),\n    (i16, 2, 2),\n    (i32, 4, 4),\n    (i64, 8, 8),\n    (i128, 16, 16),\n    (f32, 4, 4),\n    (f64, 8, 8),\n    (bool, 1, 1),\n    (char, 4, 4),\n    (TestEnum2, 32, 32),\n    (TestEnumReprU8, 40, 40),\n    (TestUnion, 8, 8)\n);\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\n#[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\nunion TestUnionDeep\u003c'a\u003e {\n    b: \u0026'a TestUnion,\n}\n\n#[cfg_attr(feature = \"derive\", derive(MemSize))]\n#[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(MemDbg))]\nunion TestUnionDeepMut\u003c'a\u003e {\n    b: \u0026'a mut TestUnion,\n}\n\n#[test]\nfn test_single_field_union_follow_ref() {\n    let mut test_union = TestUnion::default();\n    let test_union_deep = TestUnionDeep { b: \u0026test_union };\n\n    // We check that the shallow size of the test union deep is the\n    // size of a reference (i.e. an usize).\n    assert_eq!(\n        \u003cTestUnionDeep as MemSize\u003e::mem_size(\u0026test_union_deep, SizeFlags::default()),\n        core::mem::size_of::\u003cusize\u003e(),\n    );\n\n    // We check that the deep size of the test union deep is the\n    // size of a reference plus the size of the test union.\n    assert_eq!(\n        \u003cTestUnionDeep as MemSize\u003e::mem_size(\u0026test_union_deep, SizeFlags::FOLLOW_REFS),\n        core::mem::size_of::\u003cusize\u003e()\n            + \u003cTestUnion as MemSize\u003e::mem_size(\u0026test_union, SizeFlags::default()),\n    );\n\n    let test_union_deep_mut = TestUnionDeepMut { b: \u0026mut test_union };\n\n    // We check that the shallow size of the test union mut is the\n    // size of a reference (i.e. an usize)\n    assert_eq!(\n        \u003cTestUnionDeepMut as MemSize\u003e::mem_size(\u0026test_union_deep_mut, SizeFlags::default()),\n        core::mem::size_of::\u003cusize\u003e(),\n    );\n\n    // We check that the deep size of the test union deep mut is the\n    // size of a reference plus the size of the test union.\n    assert_eq!(\n        \u003cTestUnionDeepMut as MemSize\u003e::mem_size(\u0026test_union_deep_mut, SizeFlags::FOLLOW_REFS),\n        core::mem::size_of::\u003cusize\u003e()\n            + \u003cTestUnion as MemSize\u003e::mem_size(\u0026test_union, SizeFlags::default()),\n    );\n}\n","traces":[{"line":669,"address":[],"length":0,"stats":{"Line":17}},{"line":672,"address":[],"length":0,"stats":{"Line":34}},{"line":673,"address":[],"length":0,"stats":{"Line":68}},{"line":674,"address":[],"length":0,"stats":{"Line":17}},{"line":681,"address":[],"length":0,"stats":{"Line":34}},{"line":682,"address":[],"length":0,"stats":{"Line":68}},{"line":684,"address":[],"length":0,"stats":{"Line":17}},{"line":691,"address":[],"length":0,"stats":{"Line":68}},{"line":692,"address":[],"length":0,"stats":{"Line":17}},{"line":699,"address":[],"length":0,"stats":{"Line":68}},{"line":700,"address":[],"length":0,"stats":{"Line":17}},{"line":702,"address":[],"length":0,"stats":{"Line":17}},{"line":705,"address":[],"length":0,"stats":{"Line":34}},{"line":706,"address":[],"length":0,"stats":{"Line":68}},{"line":708,"address":[],"length":0,"stats":{"Line":17}},{"line":715,"address":[],"length":0,"stats":{"Line":68}},{"line":716,"address":[],"length":0,"stats":{"Line":17}},{"line":750,"address":[],"length":0,"stats":{"Line":2}}],"covered":18,"coverable":18},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_mem_size_no_import.rs"],"content":"//! Test suite to verify whether derive works properly when MemSize is not imported outside of the derive.\n\n#[allow(dead_code)]\n#[cfg_attr(feature = \"derive\", derive(mem_dbg::MemSize))]\n#[cfg_attr(all(feature = \"std\", feature = \"derive\"), derive(mem_dbg::MemDbg))]\nstruct MyTestStruct(i32);\n\n#[test]\n#[cfg(feature = \"derive\")]\nfn test_mem_size_no_import() {\n    let my_test_struct = MyTestStruct(42);\n    let mem_size = \u003cMyTestStruct as mem_dbg::MemSize\u003e::mem_size(\n        \u0026my_test_struct,\n        mem_dbg::SizeFlags::default(),\n    );\n    assert_eq!(mem_size, 4);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_minimal_pathbuf.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2025 Inria\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n#![cfg(feature = \"std\")]\n#![cfg(feature = \"derive\")]\n\nuse mem_dbg::*;\nuse std::path::PathBuf;\n\n#[test]\nfn test_pathbuf_in_struct() {\n    #[derive(MemSize, MemDbg)]\n    struct Test {\n        path_buf: PathBuf,\n    }\n    \n    let s = Test { path_buf: PathBuf::from(\"/tmp/test\") };\n    let size = s.mem_size(SizeFlags::default());\n\n    assert_eq!(size, 24);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg","tests","test_minimal_unsafe_cell.rs"],"content":"#![cfg(feature = \"std\")]\n#![cfg(feature = \"derive\")]\n\nuse mem_dbg::*;\nuse core::cell::UnsafeCell;\n\n#[test]\nfn test_minimal_unsafecell_in_struct() {\n    #[derive(MemSize, MemDbg)]\n    struct Test {\n        field: UnsafeCell\u003ci32\u003e,\n    }\n    \n    let s = Test { field: UnsafeCell::new(42) };\n    let size = s.mem_size(SizeFlags::default());\n    assert_eq!(size, 4)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","lucac","github","mem_dbg-rs","mem_dbg-derive","src","lib.rs"],"content":"/*\n * SPDX-FileCopyrightText: 2023 Tommaso Fontana\n * SPDX-FileCopyrightText: 2023 Inria\n * SPDX-FileCopyrightText: 2023 Sebastiano Vigna\n *\n * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later\n */\n\n//! Derive procedural macros for the [`mem_dbg`](https://crates.io/crates/mem_dbg) crate.\n\nuse proc_macro::TokenStream;\nuse quote::{quote, ToTokens};\nuse syn::{\n    parse_macro_input, parse_quote, parse_quote_spanned, spanned::Spanned, Data, DeriveInput,\n};\n\n/**\n\nGenerate a `mem_dbg::MemSize` implementation for custom types.\n\nPresently we do not support unions.\n\nThe attribute `copy_type` can be used on [`Copy`] types that do not contain non-`'static` references\nto make `MemSize::mem_size` faster on arrays, vectors and slices. Note that specifying\n`copy_type` will add the bound that the type is `Copy + 'static`.\n\nSee `mem_dbg::CopyType` for more details.\n\n*/\n#[proc_macro_derive(MemSize, attributes(copy_type))]\npub fn mem_dbg_mem_size(input: TokenStream) -\u003e TokenStream {\n    let mut input = parse_macro_input!(input as DeriveInput);\n\n    let input_ident = input.ident;\n    input.generics.make_where_clause();\n    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n    let mut where_clause = where_clause.unwrap().clone(); // We just created it\n\n    let is_copy_type = input\n        .attrs\n        .iter()\n        .any(|x| x.meta.path().is_ident(\"copy_type\"));\n\n    // If copy_type, add the Copy + 'static bound\n    let copy_type: syn::Expr = if is_copy_type {\n        where_clause\n            .predicates\n            .push(parse_quote_spanned!(input_ident.span()=\u003e Self: Copy + 'static));\n        parse_quote!(mem_dbg::True)\n    } else {\n        parse_quote!(mem_dbg::False)\n    };\n\n    match input.data {\n        Data::Struct(s) =\u003e {\n            let mut fields_ident = vec![];\n            let mut fields_ty = vec![];\n\n            for (field_idx, field) in s.fields.iter().enumerate() {\n                fields_ident.push(\n                    field\n                        .ident\n                        .to_owned()\n                        .map(|t| t.to_token_stream())\n                        .unwrap_or(syn::Index::from(field_idx).to_token_stream()),\n                );\n                fields_ty.push(field.ty.to_token_stream());\n                let field_ty = \u0026field.ty;\n                // Add MemSize bound to all fields\n                where_clause\n                    .predicates\n                    .push(parse_quote_spanned!(field.span()=\u003e #field_ty: mem_dbg::MemSize));\n            }\n            quote! {\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::CopyType for #input_ident #ty_generics #where_clause\n                {\n                    type Copy = #copy_type;\n                }\n\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::MemSize for #input_ident #ty_generics #where_clause {\n                    fn mem_size(\u0026self, _memsize_flags: mem_dbg::SizeFlags) -\u003e usize {\n                        let mut bytes = core::mem::size_of::\u003cSelf\u003e();\n                        #(bytes += \u003c#fields_ty as mem_dbg::MemSize\u003e::mem_size(\u0026self.#fields_ident, _memsize_flags);)*\n                        #(bytes -= core::mem::size_of::\u003c#fields_ty\u003e();)*\n                        bytes\n                    }\n                }\n            }\n        }\n\n        Data::Enum(e) =\u003e {\n            let mut variants = Vec::new();\n            let mut variants_size = Vec::new();\n\n            for variant in e.variants {\n                let mut res = variant.ident.to_owned().to_token_stream();\n                let mut var_args_summations = vec![quote! {core::mem::size_of::\u003cSelf\u003e()}];\n                let mut var_args_subtractions = Vec::new();\n                match \u0026variant.fields {\n                    syn::Fields::Unit =\u003e {}\n                    syn::Fields::Named(fields) =\u003e {\n                        let mut args = Vec::new();\n                        for field in \u0026fields.named {\n                            let field_ty = \u0026field.ty;\n                            where_clause\n                                .predicates\n                                .push(parse_quote_spanned!(field.span() =\u003e #field_ty: mem_dbg::MemSize));\n                                let field_ident = \u0026field.ident;\n                                let field_ty = field.ty.to_token_stream();\n                                var_args_summations.push(quote! {\n                                    \u003c#field_ty as mem_dbg::MemSize\u003e::mem_size(#field_ident, _memsize_flags)\n                                });\n                                var_args_subtractions.push(quote! {\n                                    core::mem::size_of::\u003c#field_ty\u003e()\n                                });\n                                args.push(field_ident.to_token_stream());\n                            }\n                        // extend res with the args sourrounded by curly braces\n                        res.extend(quote! {\n                            { #(#args,)* }\n                        });\n                    }\n                    syn::Fields::Unnamed(fields) =\u003e {\n                        let mut args = Vec::new();\n\n                        for (field_idx, field) in fields.unnamed.iter().enumerate() {\n                            let ident = syn::Ident::new(\n                                \u0026format!(\"v{}\", field_idx),\n                                proc_macro2::Span::call_site(),\n                            )\n                            .to_token_stream();\n                            let field_ty = field.ty.to_token_stream();\n                            var_args_summations.push(quote! {\n                                \u003c#field_ty as mem_dbg::MemSize\u003e::mem_size(#ident, _memsize_flags)\n                            });\n                            var_args_subtractions.push(quote! {\n                                core::mem::size_of::\u003c#field_ty\u003e()\n                            });\n                            args.push(ident);\n\n                            where_clause\n                                .predicates\n                                .push(parse_quote_spanned!(field.span()=\u003e #field_ty: mem_dbg::MemSize));\n                        }\n                        // extend res with the args sourrounded by curly braces\n                        res.extend(quote! {\n                            ( #(#args,)* )\n                        });\n                    }\n                }\n                variants.push(res);\n                variants_size.push(quote! {\n                    {\n                        let mut bytes = 0;\n                        #(bytes += #var_args_summations;)*\n                        #(bytes -= #var_args_subtractions;)*\n                        bytes\n                    }\n                });\n            }\n\n            quote! {\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::CopyType for #input_ident #ty_generics #where_clause\n                {\n                    type Copy = #copy_type;\n                }\n\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::MemSize for #input_ident #ty_generics #where_clause {\n                    fn mem_size(\u0026self, _memsize_flags: mem_dbg::SizeFlags) -\u003e usize {\n                        match self {\n                            #(\n                               #input_ident::#variants =\u003e #variants_size,\n                            )*\n                        }\n                    }\n                }\n            }\n        }\n\n        Data::Union(u) =\u003e {\n            // We only support single-field unions completely or call to mem_size on unions\n            // without the FOLLOW_REFS flag, as we cannot know programmatically\n            // which field is initialized.\n\n            let fields = u.fields.named.iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n            match fields.len() {\n                0 =\u003e unreachable!(\"Empty unions are not supported by the Rust programming language.\"),\n                1 =\u003e {\n                    let field = fields[0];\n                    let field_ty = \u0026field.ty;\n                    let ident = field.ident.as_ref().unwrap();\n                    where_clause\n                        .predicates\n                        .push(parse_quote_spanned!(field.span() =\u003e #field_ty: mem_dbg::MemSize));\n                    quote! {\n                        #[automatically_derived]\n                        impl #impl_generics mem_dbg::CopyType for #input_ident #ty_generics #where_clause\n                        {\n                            type Copy = #copy_type;\n                        }\n\n                        #[automatically_derived]\n                        impl #impl_generics mem_dbg::MemSize for #input_ident #ty_generics #where_clause {\n                            fn mem_size(\u0026self, _memsize_flags: mem_dbg::SizeFlags) -\u003e usize {\n                                unsafe{\u003c#field_ty as mem_dbg::MemSize\u003e::mem_size(\u0026self.#ident, _memsize_flags)}\n                            }\n                        }\n                    }\n                }\n                number_of_fields =\u003e unimplemented!(\n                    \"mem_dbg::MemSize for unions with more than one field ({}) is not supported.\", number_of_fields\n                )\n            }\n        }\n    }.into()\n}\n\n/**\n\nGenerate a `mem_dbg::MemDbg` implementation for custom types.\n\nPresently we do not support unions.\n\n*/\n#[proc_macro_derive(MemDbg)]\npub fn mem_dbg_mem_dbg(input: TokenStream) -\u003e TokenStream {\n    let mut input = parse_macro_input!(input as DeriveInput);\n\n    let input_ident = input.ident;\n    input.generics.make_where_clause();\n    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n    let mut where_clause = where_clause.unwrap().clone(); // We just created it\n\n    match input.data {\n        Data::Struct(s) =\u003e {\n            let mut id_offset_pushes = vec![];\n            let mut match_code = vec![];\n\n            for (field_idx, field) in s.fields.iter().enumerate() {\n                // Use the field name for named structures, and the index\n                // for tuple structures\n                let field_ident = field\n                    .ident\n                    .to_owned()\n                    .map(|t| t.to_token_stream())\n                    .unwrap_or_else(|| syn::Index::from(field_idx).to_token_stream());\n\n                let field_ident_str = field\n                    .ident\n                    .to_owned()\n                    .map(|t| t.to_string().to_token_stream())\n                    .unwrap_or_else(|| field_idx.to_string().to_token_stream());\n\n                let field_ty = \u0026field.ty;\n                where_clause\n                    .predicates\n                    .push(parse_quote_spanned!(field.span() =\u003e #field_ty: mem_dbg::MemDbgImpl));\n\n                // We push the field index and its offset\n                id_offset_pushes.push(quote!{\n                    id_sizes.push((#field_idx, core::mem::offset_of!(#input_ident #ty_generics, #field_ident)));\n                });\n                // This is the arm of the match statement that invokes\n                // _mem_dbg_depth_on on the field.\n                match_code.push(quote!{\n                    #field_idx =\u003e \u003c#field_ty as mem_dbg::MemDbgImpl\u003e::_mem_dbg_depth_on(\u0026self.#field_ident, _memdbg_writer, _memdbg_total_size, _memdbg_max_depth, _memdbg_prefix, Some(#field_ident_str), i == n - 1, padded_size, _memdbg_flags)?,\n                });\n            }\n\n            quote! {\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::MemDbgImpl for #input_ident #ty_generics #where_clause {\n                    #[inline(always)]\n                    fn _mem_dbg_rec_on(\n                        \u0026self,\n                        _memdbg_writer: \u0026mut impl core::fmt::Write,\n                        _memdbg_total_size: usize,\n                        _memdbg_max_depth: usize,\n                        _memdbg_prefix: \u0026mut String,\n                        _memdbg_is_last: bool,\n                        _memdbg_flags: mem_dbg::DbgFlags,\n                    ) -\u003e core::fmt::Result {\n                        let mut id_sizes: Vec\u003c(usize, usize)\u003e = vec![];\n                        #(#id_offset_pushes)*\n                        let n = id_sizes.len();\n                        id_sizes.push((n, core::mem::size_of::\u003cSelf\u003e()));\n                        // Sort by offset\n                        id_sizes.sort_by_key(|x| x.1);\n                        // Compute padded sizes\n                        for i in 0..n {\n                            id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;\n                        };\n                        // Put the candle back unless the user requested otherwise\n                        if ! _memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {\n                            id_sizes.sort_by_key(|x| x.0);\n                        }\n\n                        for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n) {\n                            match field_idx {\n                                #(#match_code)*\n                                _ =\u003e unreachable!(),\n                            }\n                        }\n                        Ok(())\n                    }\n                }\n            }\n        }\n\n        Data::Enum(e) =\u003e {\n            let mut variants = Vec::new();\n            let mut variants_code = Vec::new();\n\n            for variant in \u0026e.variants {\n                let variant_ident = \u0026variant.ident;\n                let mut res = variant.ident.to_owned().to_token_stream();\n                // Depending on the presence of the feature offset_of_enum, this\n                // will contains field indices and offset_of or field indices\n                // and size_of; in the latter case, we will assume size_of to be\n                // the padded size, resulting in no padding.\n                let mut id_offset_pushes = vec![];\n                let mut match_code = vec![];\n                let mut arrow = '';\n                match \u0026variant.fields {\n                    syn::Fields::Unit =\u003e {},\n                    syn::Fields::Named(fields) =\u003e {\n                        let mut args = proc_macro2::TokenStream::new();\n                        if !fields.named.is_empty() {\n                            arrow = '';\n                        }\n                        for (field_idx, field) in fields.named.iter().enumerate() {\n                            let field_ty = \u0026field.ty;\n                            let field_ident = field.ident.as_ref().unwrap();\n                            let field_ident_str = format!(\"{}\", field_ident);\n\n                            #[cfg(feature = \"offset_of_enum\")]\n                            id_offset_pushes.push(quote!{\n                                // We push the offset of the field, which will\n                                // be used to compute the padded size.\n                                id_sizes.push((#field_idx, core::mem::offset_of!(#input_ident #ty_generics, #variant_ident . #field_ident)));\n                            });\n                            #[cfg(not(feature = \"offset_of_enum\"))]\n                            id_offset_pushes.push(quote!{\n                                id_sizes.push((#field_idx, core::mem::offset_of!(#input_ident #ty_generics, #variant_ident . #field_ident)));\n                                // We push the size of the field, which will be\n                                // used as a surrogate of the padded size.\n                                id_sizes.push((#field_idx, std::mem::size_of_val(#field_ident)));\n                            });\n\n                            // This is the arm of the match statement that\n                            // invokes _mem_dbg_depth_on on the field.\n                            match_code.push(quote! {\n                                #field_idx =\u003e \u003c#field_ty as mem_dbg::MemDbgImpl\u003e::_mem_dbg_depth_on(#field_ident, _memdbg_writer, _memdbg_total_size, _memdbg_max_depth, _memdbg_prefix, Some(#field_ident_str), i == n - 1, padded_size, _memdbg_flags)?,\n                            });\n                            args.extend([field_ident.to_token_stream()]);\n                            args.extend([quote! {,}]);\n\n                            let field_ty = \u0026field.ty;\n                            where_clause\n                                .predicates\n                                .push(parse_quote_spanned!(field.span()=\u003e #field_ty: mem_dbg::MemDbgImpl));\n                        }\n                        // extend res with the args sourrounded by curly braces\n                        res.extend(quote! {\n                            // TODO: sanitize somehow the names or it'll be\n                            // havoc.\n                            { #args }\n                        });\n                    }\n                    syn::Fields::Unnamed(fields) =\u003e {\n                        let mut args = proc_macro2::TokenStream::new();\n                        if !fields.unnamed.is_empty() {\n                            arrow = '';\n                        }\n                        for (field_idx, field) in fields.unnamed.iter().enumerate() {\n                            let field_ident = syn::Ident::new(\n                                \u0026format!(\"v{}\", field_idx),\n                                proc_macro2::Span::call_site(),\n                            )\n                            .to_token_stream();\n                            let field_ty = \u0026field.ty;\n                            let field_ident_str = format!(\"{}\", field_idx);\n                            let _field_tuple_idx = syn::Index::from(field_idx);\n\n                            #[cfg(feature = \"offset_of_enum\")]\n                            id_offset_pushes.push(quote!{\n                                // We push the offset of the field, which will\n                                // be used to compute the padded size.\n                                id_sizes.push((#field_idx, core::mem::offset_of!(#input_ident #ty_generics, #variant_ident . #_field_tuple_idx)));\n                            });\n\n                            #[cfg(not(feature = \"offset_of_enum\"))]\n                            id_offset_pushes.push(quote!{\n                                // We push the size of the field, which will be\n                                // used as a surrogate of the padded size.\n                                id_sizes.push((#field_idx, std::mem::size_of_val(#field_ident)));\n                            });\n\n                            // This is the arm of the match statement that\n                            // invokes _mem_dbg_depth_on on the field.\n                            match_code.push(quote! {\n                                #field_idx =\u003e \u003c#field_ty as mem_dbg::MemDbgImpl\u003e::_mem_dbg_depth_on(#field_ident, _memdbg_writer, _memdbg_total_size, _memdbg_max_depth, _memdbg_prefix, Some(#field_ident_str), i == n - 1, padded_size, _memdbg_flags)?,\n                            });\n\n                            args.extend([field_ident]);\n                            args.extend([quote! {,}]);\n\n                            let field_ty = \u0026field.ty;\n                            where_clause\n                                .predicates\n                                .push(parse_quote_spanned!(field.span()=\u003e #field_ty: mem_dbg::MemDbgImpl));\n                        }\n                        // extend res with the args sourrounded by curly braces\n                        res.extend(quote! {\n                            ( #args )\n                        });\n                    }\n                }\n                variants.push(res);\n                let variant_name = format!(\"Variant: {}\\n\", variant.ident);\n                variants_code.push(quote!{{\n                    _memdbg_writer.write_char(#arrow)?;\n                    _memdbg_writer.write_char('')?;\n                    _memdbg_writer.write_str(#variant_name)?;\n                }});\n\n                // There's some abundant code duplication here, but we need to\n                // keep the #[cfg] attributes outside of the quote! macro.\n\n                #[cfg(feature = \"offset_of_enum\")]\n                variants_code.push(quote!{{\n                    let mut id_sizes: Vec\u003c(usize, usize)\u003e = vec![];\n                    #(#id_offset_pushes)*\n                    let n = id_sizes.len();\n\n                    // We use the offset_of information to build the real\n                    // space occupied by a field.\n                    id_sizes.push((n, core::mem::size_of::\u003cSelf\u003e()));\n                    // Sort by offset\n                    id_sizes.sort_by_key(|x| x.1);\n                    // Compute padded sizes\n                    for i in 0..n {\n                        id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;\n                    };\n                    // Put the candle back unless the user requested otherwise\n                    if ! _memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {\n                        id_sizes.sort_by_key(|x| x.0);\n                    }\n\n                    for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n) {\n                        match field_idx {\n                            #(#match_code)*\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }});\n\n                #[cfg(not(feature = \"offset_of_enum\"))]\n                variants_code.push(quote!{{\n                    let mut id_sizes: Vec\u003c(usize, usize)\u003e = vec![];\n                    #(#id_offset_pushes)*\n                    let n = id_sizes.len();\n\n                    // Lacking offset_of for enums, id_sizes contains the\n                    // size_of of each field which we use as a surrogate of\n                    // the padded size.\n                    assert!(!_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT), \"DbgFlags::RUST_LAYOUT for enums requires the offset_of_enum feature\");\n\n                    for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n) {\n                        match field_idx {\n                            #(#match_code)*\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }});\n            }\n\n            quote! {\n                #[automatically_derived]\n                impl #impl_generics mem_dbg::MemDbgImpl  for #input_ident #ty_generics #where_clause {\n                    #[inline(always)]\n                    fn _mem_dbg_rec_on(\n                        \u0026self,\n                        _memdbg_writer: \u0026mut impl core::fmt::Write,\n                        _memdbg_total_size: usize,\n                        _memdbg_max_depth: usize,\n                        _memdbg_prefix: \u0026mut String,\n                        _memdbg_is_last: bool,\n                        _memdbg_flags: mem_dbg::DbgFlags,\n                    ) -\u003e core::fmt::Result {\n                        let mut _memdbg_digits_number = mem_dbg::n_of_digits(_memdbg_total_size);\n                        if _memdbg_flags.contains(mem_dbg::DbgFlags::SEPARATOR) {\n                            _memdbg_digits_number += _memdbg_digits_number / 3;\n                        }\n                        if _memdbg_flags.contains(mem_dbg::DbgFlags::HUMANIZE) {\n                            _memdbg_digits_number = 6;\n                        }\n\n                        if _memdbg_flags.contains(mem_dbg::DbgFlags::PERCENTAGE) {\n                            _memdbg_digits_number += 8;\n                        }\n\n                        for _ in 0.._memdbg_digits_number + 3 {\n                            _memdbg_writer.write_char(' ')?;\n                        }\n                        if !_memdbg_prefix.is_empty() {\n                            _memdbg_writer.write_str(\u0026_memdbg_prefix[2..])?;\n                        }\n                        match self {\n                            #(\n                               #input_ident::#variants =\u003e #variants_code,\n                            )*\n                        }\n                        Ok(())\n                   }\n                }\n            }\n        }\n\n        Data::Union(u) =\u003e {\n            // We only support single-field unions for the MemDbg.\n\n            let fields = u.fields.named.iter().collect::\u003cVec\u003c_\u003e\u003e();\n\n            match fields.len() {\n                0 =\u003e unreachable!(\"Empty unions are not supported by the Rust programming language.\"),\n                1 =\u003e {\n                    let field = fields[0];\n                    let field_ty = \u0026field.ty;\n                    let ident = field.ident.as_ref().unwrap();\n                    where_clause\n                        .predicates\n                        .push(parse_quote_spanned!(field.span() =\u003e #field_ty: mem_dbg::MemDbgImpl));\n                    quote! {\n                        #[automatically_derived]\n                        impl #impl_generics mem_dbg::MemDbgImpl for #input_ident #ty_generics #where_clause {\n                            #[inline(always)]\n                            fn _mem_dbg_rec_on(\n                                \u0026self,\n                                _memdbg_writer: \u0026mut impl core::fmt::Write,\n                                _memdbg_total_size: usize,\n                                _memdbg_max_depth: usize,\n                                _memdbg_prefix: \u0026mut String,\n                                _memdbg_is_last: bool,\n                                _memdbg_flags: mem_dbg::DbgFlags,\n                            ) -\u003e core::fmt::Result {\n                                unsafe{\u003c#field_ty as mem_dbg::MemDbgImpl\u003e::_mem_dbg_depth_on(\u0026self.#ident, _memdbg_writer, _memdbg_total_size, _memdbg_max_depth, _memdbg_prefix, None, _memdbg_is_last, core::mem::size_of::\u003c#field_ty\u003e(), _memdbg_flags)}\n                            }\n                        }\n                    }\n                }\n                _ =\u003e unimplemented!(\n                    \"mem_dbg::MemDbg for unions with more than one field is not supported.\"\n                )\n            }\n        }\n    }.into()\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":183}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>